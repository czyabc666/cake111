<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cake蛋糕装饰应用</title>
    <style>
        /* 初始覆盖层样式 */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.8s cubic-bezier(0.2,0.8,0.2,1), visibility 0.8s;
            visibility: visible;
            opacity: 1;
            background: transparent;
        }

        /* 三层背景 */
        .parallax-layer {
            position: absolute;
            inset: 0;
            background-position: center;
            background-size: cover;
            will-change: transform;
            pointer-events: none;
        }
        .layer-bg { background-image: url("images/parallax-bg.jpg"); z-index: 1; }
        .layer-mid { background-image: url("images/parallax-mid.png"); z-index: 2; }
        .layer-fg { background-image: url("images/parallax-fg.png"); z-index: 3; }

        /* UI 层在最上面 */
        .overlay-ui {
            position: relative;
            z-index: 5;
            text-align: center;
        }

        /* 重启覆盖层 */
        #restart-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: url('images/restart-bg.jpg') no-repeat center center / cover;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9998;
            transition: opacity 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), visibility 0.8s;
            visibility: hidden;
            opacity: 0;
        }

        /* 艺术发光标题样式 */
        #fantasy-title {
            margin-bottom: 2rem;
            display: inline-block;
            animation: titlePulse 3s infinite alternate;
        }

        #fantasy-title img {
            width: 1000px;
            height: auto;
            display: block;
        }

        @keyframes titlePulse {
            0%   { transform: translateX(100px) scale(0.95); }
            50%  { transform: translateX(100px) scale(1.05); }
            100% { transform: translateX(100px) scale(0.95); }
        }

        /* Start按钮样式 */
        #overlay {
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        #start-btn {
            padding: 0;
            border: none;
            background: transparent;
            cursor: pointer;
            outline: none;
            animation: bounceGlow 2s infinite ease-in-out;
            display: inline-block;
        }

        #start-btn img {
            display: block;
            width: 200px !important;
            height: auto;
            pointer-events: none;
        }

        /* Restart按钮样式 */
        #restart-btn {
            padding: 1.2rem 3.5rem;
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Arial', sans-serif;
            background-color: #ff6b9e;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 
                0 6px 20px rgba(255, 107, 158, 0.5),
                inset 0 -3px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            outline: none;
            transform: scale(1);
            animation: buttonPulse 2s infinite alternate;
        }

        /* 覆盖层隐藏状态 */
        #overlay.hidden, #restart-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* 覆盖层显示状态 */
        #restart-overlay.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* 原有样式保持不变 */
        body { 
            margin: 0; 
            overflow: hidden; 
        }
        #container { width: 100%; height: 100vh; }
        #loading { 
            display: none; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            background: rgba(255,255,255,0.8);
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #progress { width: 300px; height: 20px; border: 1px solid #ddd; margin: 10px 0; border-radius: 10px; overflow: hidden; }
        #progress-bar { height: 100%; background: linear-gradient(90deg, #ff69b4, #4fc3f7); width: 0%; }
        #status { color: #333; font-size: 14px; }
        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .dragging提示 {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0.7;
        }
        #excellent-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6rem;
            font-weight: 900;
            font-family: 'Arial Black', Impact, sans-serif;
            text-transform: uppercase;
            letter-spacing: -2px;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            background: linear-gradient(135deg, #9370db 0%, #4fc3f7 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 
                0 0 10px rgba(147, 112, 219, 0.7),
                0 0 20px rgba(147, 112, 219, 0.5),
                0 0 30px rgba(79, 195, 247, 0.5),
                0 0 40px rgba(79, 195, 247, 0.3),
                0 2px 5px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -50%) rotate(-2deg) scale(0.9);
            pointer-events: none;
            z-index: 1000;
            animation: pulse 2s infinite alternate;
        }
        @keyframes pulse {
            0% {
                text-shadow: 
                    0 0 10px rgba(147, 112, 219, 0.7),
                    0 0 20px rgba(147, 112, 219, 0.5),
                    0 0 30px rgba(79, 195, 247, 0.5),
                    0 0 40px rgba(79, 195, 247, 0.3);
                transform: translate(-50%, -50%) rotate(-2deg) scale(0.9);
            }
            100% {
                text-shadow: 
                    0 0 15px rgba(147, 112, 219, 0.9),
                    0 0 30px rgba(147, 112, 219, 0.7),
                    0 0 45px rgba(79, 195, 247, 0.7),
                    0 0 60px rgba(79, 195, 247, 0.5);
                transform: translate(-50%, -50%) rotate(-2deg) scale(1);
            }
        }
    
        /* 粒子容器 */
        #cute-effects {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            font-size: 20px;
            animation: floatDown 6s linear;
            opacity: 0.9;
            transform: translateY(-20%);
            will-change: transform, opacity;
        }
        @keyframes floatDown {
            0% { transform: translateY(-10%) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110%) rotate(360deg); opacity: 0; }
        }
        #music-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border: none;
            background: transparent;
            cursor: pointer;
            z-index: 2000;
            padding: 0;
        }

        #music-btn img {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* --- 泡泡效果 --- */
        #bubble-container { position: absolute; inset: 0; pointer-events: none; z-index: 90; overflow: hidden; }
        .bubble {
            position: absolute;
            background-image: url('images/bubble.png');
            background-size: cover; background-repeat: no-repeat;
            border-radius: 50%;
            opacity: 0.95;
            will-change: transform, opacity;
            animation: bubbleFloat linear forwards;
        }
        @keyframes bubbleFloat {
            0% { transform: translateY(10vh) scale(1); opacity: 0.95; }
            100% { transform: translateY(-30vh) scale(1.12); opacity: 0; }
        }
        /* DOM 粒子 (excellent 专用) */
        .particle-dom {
            position: absolute; width: 28px; height:28px;
            background-image: url('images/particle.png'); background-size: contain; background-repeat:no-repeat;
            pointer-events:none; opacity:0.95;
            will-change: transform, opacity;
            animation: particleFall 1.2s linear forwards;
        }
        @keyframes particleFall {
            0% { transform: translateY(0) scale(0.9); opacity: 1; }
            100% { transform: translateY(-160px) scale(1.1); opacity: 0; }
        }

        /* 动画效果增强 */
        .glow {
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
        }

        @keyframes floatAnimation {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-15px) rotate(2deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }

        .floating {
            animation: floatAnimation 3s ease-in-out infinite;
        }

        @keyframes spinAnimation {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        .spinning {
            animation: spinAnimation 8s linear infinite;
        }

        @keyframes colorPulse {
            0% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
            100% { filter: hue-rotate(0deg); }
        }

        .color-pulse {
            animation: colorPulse 6s ease-in-out infinite;
        }
    </style>
</head>
<body>
    
    <!-- 初始覆盖层 -->
    <div id="overlay">
        <div id="parallax-container">
            <!-- 三层分层背景 -->
            <div class="parallax-layer layer-bg"></div>
            <div class="parallax-layer layer-mid"></div>
            <div class="parallax-layer layer-fg"></div>

            <!-- UI 层 -->
            <div class="overlay-ui">
                <h1 id="fantasy-title">
                    <img src="images/my-title.png" alt="Fantasy Cake" />
                </h1>

                <button id="start-btn">
                    <img src="images/start-icon.png" alt="Start" />
                </button>

                <!-- 音乐按钮 -->
                <button id="music-btn">
                    <img id="music-icon" src="images/music-on.png" alt="音乐开关" />
                </button>

                <!-- 可爱特效容器 -->
                <div id="bubble-container"></div>
                <div id="cute-effects"></div>
            </div>
        </div>
    </div>
    <!-- 重启覆盖层 -->
    <div id="restart-overlay">
        <button id="restart-btn">Restart</button>
    </div>

    <!-- 3D内容容器 -->
    <div id="container"></div>
    <div id="loading">
        <h3 style="color: #333; margin-top: 0;">加载中...</h3>
        <div id="progress"><div id="progress-bar"></div></div>
        <div id="status">小蛋糕准备中...</div>
    </div>
    <!-- BGM 控制按钮（左上角） -->
    <button id="music-btn">
        <img id="music-icon" src="images/music-on.png" alt="音乐开关">
    </button>

    <!-- 全局 BGM 音频 -->
    <audio id="bgm" src="audio/bgm.mp3" loop></audio>
    <div class="tooltip"></div>
    <div class="dragging提示">拖动装饰物来装饰你的小蛋糕吧~</div>
    <div id="excellent-text">excellent！</div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    
    
    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let threeJsInitialized = false;
        let mixer; // 动画混合器，用于控制yh模型动画
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('overlay');
            const startBtn = document.getElementById('start-btn');
            const restartOverlay = document.getElementById('restart-overlay');
            const restartBtn = document.getElementById('restart-btn');
            const loading = document.getElementById('loading');
            const cuteEffects = document.getElementById('cute-effects');
            
            // BGM 控制逻辑
            const musicBtn = document.getElementById('music-btn');
            const musicIcon = document.getElementById('music-icon');
            const bgm = document.getElementById('bgm');
            let isPlaying = false;

            musicBtn.addEventListener('click', () => {
                if (isPlaying) {
                    bgm.pause();
                    isPlaying = false;
                    musicIcon.src = 'images/music-off.png';
                } else {
                    bgm.play().catch(err => console.log('BGM播放失败', err));
                    isPlaying = true;
                    musicIcon.src = 'images/music-on.png';
                }
            });

            // 点击 Start 按钮
            startBtn.addEventListener('click', function () {
                overlay.classList.add('hidden');
                loading.style.display = 'block';
                // 播放 BGM
                bgm.play().catch(err => console.log('BGM播放失败', err));
                isPlaying = true;
                musicIcon.src = 'images/music-on.png';

                // 游戏背景
                document.body.style.background = "url('images/game-bg.jpg') no-repeat center center / cover";

                // 延迟启动 3D
                setTimeout(init3DCakeViewer, 500);
            });

            // 初始页面背景随鼠标轻微偏移
            document.addEventListener('mousemove', (e) => {
                const overlayEl = document.getElementById('overlay');
                if (!overlayEl || overlayEl.classList.contains('hidden')) return;
                const moveX = (e.clientX / window.innerWidth - 0.5) * 10;
                const moveY = (e.clientY / window.innerHeight - 0.5) * 10;
                overlayEl.style.backgroundPosition = `${50 + moveX}% ${50 + moveY}%`;
                const scale = 1.02 + (Math.abs(moveX) + Math.abs(moveY)) / 400;
                overlayEl.style.transform = `scale(${scale})`;
            });

            // 随机生成可爱粒子
            function spawnParticle() {
                const cuteEffects = document.getElementById('cute-effects');
                if (!cuteEffects) return;
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = Math.random() * 100 + '%';
                particle.style.fontSize = (12 + Math.random() * 20) + 'px';
                particle.textContent = Math.random() > 0.5 ? '' : '';
                cuteEffects.appendChild(particle);
                const drift = (Math.random() - 0.5) * 30;
                particle.style.transform = `translateX(${drift}px)`;
                setTimeout(() => {
                    particle.remove();
                }, 6200);
            }
            // 初始页面显示时生成粒子
            let particleInterval = setInterval(() => {
                const overlayEl = document.getElementById('overlay');
                if (overlayEl && !overlayEl.classList.contains('hidden')) spawnParticle();
            }, 900);

            // 点击Restart按钮，恢复到初始状态
            restartBtn.addEventListener('click', function() {
                // 隐藏重启覆盖层
                restartOverlay.classList.remove('visible');
                restartOverlay.classList.add('hidden');
                
                // 完全重置页面到初始状态
                fullResetToInitialState();
            });
        });

        // 完全重置到页面刚打开的状态
        function fullResetToInitialState() {
            // 清除所有Three.js实例
            if (scene) {
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentElement) {
                renderer.domElement.parentElement.removeChild(renderer.domElement);
            }
            
            // 停止并清除动画混合器
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            
            // 重置所有变量
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            threeJsInitialized = false;
            
            // 显示初始覆盖层
            const overlay = document.getElementById('overlay');
            overlay.classList.remove('hidden');
            
            // 重置加载状态
            document.getElementById('loading').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('status').textContent = '准备加载模型';
            
            // 重置excellent文字
            const excellentText = document.getElementById('excellent-text');
            excellentText.style.opacity = 0;
        }

        // 初始化3D蛋糕查看器
        function init3DCakeViewer() {
            if (threeJsInitialized) return;
            threeJsInitialized = true;
            
            // 所有模型坐标集中配置区
            const MODEL_COORDINATES = {
                cake: { 
                    position: { x: 0, y: -2, z: 0 },
                    scale: 5,
                    visible: true
                },
                zisedangao: { 
                    position: { x: 4, y: -2, z: -5 },
                    scale: 1.5,
                    visible: false
                },
                fensedangao: { 
                    position: { x: 0, y: 5, z: 0 },
                    scale: 10,
                    visible: false
                },
                jianhao: { 
                    position: { x: 13, y: -6, z: 4 },
                    scale: 2,
                    visible: true,
                    rotation: { x: Math.PI / 3, y: 0, z: 0 },
                    color: 0x87CEEB
                },
                o: { 
                    position: { x: -18, y: -9, z: 5 },
                    scale: 0.17,
                    visible: true,
                    color: 0xffff00,
                    draggable: false,
                    rotation: { x: Math.PI / 3, y: 0, z: 0 },
                    linkToJianhao: true
                },
                caomei: { 
                    position: { x: 8, y: -2, z: 6 },
                    scale: 0.08,
                    visible: false,
                    initialPos: { x: 8, y: -2, z: 6 }
                },
                lanmei: { 
                    position: { x: 3, y: -2, z: 6 },
                    scale: 150,
                    visible: false,
                    initialPos: { x: 3, y: -2, z: 6 }
                },
                oreo: { 
                    position: { x: -3, y: -1.5, z: 6 },
                    scale: 0.3,
                    visible: false,
                    color: 0x8B4513,
                    initialPos: { x: -3, y: -1.5, z: 6 }
                },
                yingtao: { 
                    position: { x: -8, y: -2, z: 6 },
                    scale: 0.8,
                    visible: false,
                    initialPos: { x: -8, y: -2, z: 6 }
                },
                a: { 
                    position: { x: 5, y: -2, z: 9 },
                    scale: 0.3,
                    visible: false,
                    initialPos: { x: 5, y: -2, z: 9 },
                    rotation: { x: 0, y: 0, z: -Math.PI / 6 },
                    alwaysDraggable: true
                },
                b: { 
                    position: { x: 0, y: 0, z: 10 },
                    scale: 1,
                    visible: false,
                    initialPos: { x: 0, y: 0, z: 10 },
                    color: 0xffd1dc,
                    alwaysDraggable: true
                },
                c: { 
                    position: { x: -5, y: -1, z: 9 },
                    scale: 0.01,
                    visible: false,
                    initialPos: { x: -5, y: -1, z: 9 },
                    rotation: { x: 0, y: 0, z: Math.PI / 6 },
                    alwaysDraggable: true
                },
                yh: { // yh模型配置 - 动画模型
                    position: { x: 0, y: -3, z: 2 }, // 目标显示位置
                    scale: 0.5, // 缩放比例
                    visible: false, // 初始隐藏
                    initialPos: { x: 0, y: -5, z: 2 },
                    draggable: false,
                    hasAnimation: true, // 标记为有动画的模型
                    animationSpeed: 2.0, // 动画速度
                    rotation: { x: 0, y: Math.PI, z: 0 },
                    loopAnimation: false // 动画是否循环
                }
            };
            
            const SPHERE_COORDINATES = [
                { 
                    position: { x: -6, y: -6, z: 5 },
                    color: 0xffffe0, 
                    size: 1.5, 
                    type: 'showCake', 
                    tooltip: '原味奶油蛋糕' 
                },
                { 
                    position: { x: 0, y: -6, z: 5 },
                    color: 0xffc0cb, 
                    size: 1.5, 
                    type: 'showFenSe', 
                    tooltip: '草莓奶油蛋糕' 
                },
                { 
                    position: { x: 5, y: -6, z: 5 },
                    color: 0x9370db, 
                    size: 1.5, 
                    type: 'showZiSe', 
                    tooltip: '蓝莓奶油蛋糕' 
                }
            ];

            // 常量定义区
            const DRAGGABLE_MODELS = ['caomei', 'lanmei', 'oreo', 'yingtao', 'a', 'b', 'c'];
            const NEW_MODELS = ['a', 'b', 'c'];
            const POSITION_TOLERANCE = 0.1;

            // 局部变量区
            const models = {};
            const spheres = [];
            let loaded = 0, total = Object.keys(MODEL_COORDINATES).length;
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let tooltip;
            let jianhaoClicked = false;
            let jianhaoConfirmed = false;
            let jianhaoFinalized = false;
            let jianhaoPermanentlyHidden = false;
            const clickableObjects = [];
            let draggedObject = null;
            const dragOffset = new THREE.Vector3();
            let isDraggingModel = false;
            let isRotatingView = false;
            let excellentText;
            let isCameraAnimating = false;
            const restartOverlay = document.getElementById('restart-overlay');

            // 初始化函数
            function init() {
                tooltip = document.querySelector('.tooltip');
                excellentText = document.getElementById('excellent-text');
                
                // 初始化场景
                scene = new THREE.Scene();
                scene.background = null;
                
                // 初始化相机
                camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 15, 30);

                // 初始化渲染器
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('container').appendChild(renderer.domElement);

                // 光源设置
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 20, 15);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 50;
                scene.add(dirLight);

                // 创建交互球体
                createSpheres();

                // 初始化控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.target.set(0, 1, 0);
                controls.maxDistance = 60;
                controls.minDistance = 10;
                controls.enableRotate = true;
                controls.enableZoom = true;
                controls.enablePan = false;

                // 初始化加载器
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                const loader = new THREE.GLTFLoader();
                loader.setDRACOLoader(dracoLoader);
                
                // 加载所有模型
                loadAllModels(loader);

                // 事件监听
                window.addEventListener('resize', onResize);
                window.addEventListener('mousedown', onMouseDown, false);
                window.addEventListener('mousemove', onMouseMove, false);
                window.addEventListener('mouseup', onMouseUp, false);
                window.addEventListener('mouseleave', onMouseUp, false);
                
                // 启动动画
                animate();
            }

            // 相机动画函数
            function animateCamera(targetPosition, duration, onComplete) {
                const startPosition = new THREE.Vector3().copy(camera.position);
                const startTime = performance.now();
                isCameraAnimating = true;
                controls.enabled = false;
                
                function update(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = progress * (2 - progress);
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        isCameraAnimating = false;
                        controls.enabled = true;
                        if (onComplete) onComplete();
                    }
                }
                
                requestAnimationFrame(update);
            }

            // 播放yh模型的动画
            function playYHAnimation() {
                if (models.yh && models.yh.animations && models.yh.animations.length > 0 && mixer) {
                    // 停止之前的所有动画
                    mixer.stopAllAction();
                    
                    // 播放第一个动画剪辑
                    const action = mixer.clipAction(models.yh.animations[0]);
                    
                    // 根据配置设置动画属性
                    action.setEffectiveTimeScale(MODEL_COORDINATES.yh.animationSpeed);
                    action.setLoop(MODEL_COORDINATES.yh.loopAnimation ? THREE.LoopRepeat : THREE.LoopOnce);
                    
                    // 播放动画
                    action.play();
                }
            }

            // 显示excellent文字和动画yh模型
            function showExcellent() {
                if (models.jianhao && models.jianhao.obj) {
                    models.jianhao.obj.visible = false;
                    jianhaoPermanentlyHidden = true;
                }
                
                if (models.o && models.o.obj) {
                    models.o.obj.visible = false;
                }
                
                // 显示yh模型并播放动画
                if (models.yh && models.yh.obj) {
                    models.yh.obj.visible = true;
                    
                    // 为yh模型添加额外的浮动和发光效果
                    models.yh.obj.traverse(child => {
                        if (child.isMesh) {
                            child.material.emissive.set(0xffff00); // 粉色发光
                            child.material.emissiveIntensity = 0.5;
                        }
                    });
                    
                    // 添加淡入动画
                    models.yh.obj.scale.set(0, 0, 0);
                    if (typeof gsap !== 'undefined') {
                        gsap.to(models.yh.obj.scale, {
                            x: MODEL_COORDINATES.yh.scale,
                            y: MODEL_COORDINATES.yh.scale,
                            z: MODEL_COORDINATES.yh.scale,
                            duration: 0.8,
                            ease: 'elastic.out(1, 0.6)',
                            onComplete: playYHAnimation // 动画完成后播放模型动画
                        });
                    } else {
                        models.yh.obj.scale.set(
                            MODEL_COORDINATES.yh.scale,
                            MODEL_COORDINATES.yh.scale,
                            MODEL_COORDINATES.yh.scale
                        );
                        playYHAnimation(); // 播放模型动画
                    }
                }
                
                const targetCameraPosition = new THREE.Vector3(0, 15, 15);
                animateCamera(targetCameraPosition, 1500, () => {
                    excellentText.style.opacity = 0;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.7)';
                    
                    void excellentText.offsetWidth;
                    
                    excellentText.style.opacity = 1;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(1)';
                    
                    // excellent消失后2秒显示重启覆盖层
                    setTimeout(() => {
                        excellentText.style.opacity = 0;
                        excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.7)';
                        
                        // 2秒后显示重启覆盖层
                        setTimeout(() => {
                            restartOverlay.classList.remove('hidden');
                            restartOverlay.classList.add('visible');
                        }, 2000);
                    }, 2000);
                });
            }

            // 球体创建函数
            function createSpheres() {
                SPHERE_COORDINATES.forEach((sphereProps) => {
                    const geometry = new THREE.SphereGeometry(sphereProps.size, 32, 32);
                    const material = new THREE.MeshStandardMaterial({
                        color: sphereProps.color,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    
                    const sphereMesh = new THREE.Mesh(geometry, material);
                    sphereMesh.position.set(
                        sphereProps.position.x, 
                        sphereProps.position.y, 
                        sphereProps.position.z
                    );
                    
                    sphereMesh.castShadow = true;
                    sphereMesh.receiveShadow = true;
                    sphereMesh.userData.type = sphereProps.type;
                    sphereMesh.userData.isSphere = true;
                    sphereMesh.userData.tooltip = sphereProps.tooltip;
                    
                    scene.add(sphereMesh);
                    spheres.push({ mesh: sphereMesh, ...sphereProps });
                    clickableObjects.push(sphereMesh);
                });
            }

            // 模型加载函数 - 特别处理yh动画模型
            function loadAllModels(loader) {
                Object.keys(MODEL_COORDINATES).forEach(key => {
                    const coords = MODEL_COORDINATES[key];
                    models[key] = { 
                        obj: null, 
                        animations: [], // 存储动画剪辑
                        loaded: false, 
                        visible: coords.visible,
                        initialPos: coords.initialPos || null,
                        isConfirmed: false,
                        isNewModel: NEW_MODELS.includes(key),
                        draggable: coords.draggable || false,
                        linkToJianhao: coords.linkToJianhao || false,
                        hasAnimation: coords.hasAnimation || false
                    };
                    
                    loadModel(loader, key, `./${key}/scene.gltf`, 
                        coords.position.x, coords.position.y, coords.position.z, 
                        coords.scale, coords.visible, 
                        coords.rotation || null, coords.color || null
                    );
                });
            }

            function getModelName(key) {
                const nameMap = {
                    cake: '原味蛋糕',
                    zisedangao: '紫色蛋糕',
                    fensedangao: '粉色蛋糕',
                    jianhao: '加号控件',
                    o: '模型O',
                    caomei: '草莓',
                    lanmei: '蓝莓',
                    oreo: '奥利奥',
                    yingtao: '樱桃',
                    a: '模型A',
                    b: '模型B',
                    c: '模型C',
                    yh: 'YH动画模型' // yh模型名称
                };
                return nameMap[key] || key;
            }

            function loadModel(loader, key, url, x, y, z, scale, visible, rotation, color) {
                document.getElementById('status').textContent = `加载${getModelName(key)}模型...`;
                
                loader.load(
                    url, 
                    (gltf) => {
                        const model = gltf.scene;
                        model.position.set(x, y, z);
                        model.scale.set(scale, scale, scale);
                        model.visible = visible;
                        
                        // 存储动画剪辑（如果是yh模型）
                        if (key === 'yh' && gltf.animations && gltf.animations.length > 0) {
                            models[key].animations = gltf.animations;
                            
                            // 初始化动画混合器
                            if (!mixer) {
                                mixer = new THREE.AnimationMixer(model);
                            }
                        }
                        
                        if (rotation) {
                            model.rotation.set(rotation.x, rotation.y, rotation.z);
                        }
                        
                        const coords = MODEL_COORDINATES[key];
                        model.userData = {
                            type: key,
                            draggable: coords.draggable || false,
                            isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                            isNewModel: NEW_MODELS.includes(key),
                            isJianhao: key === 'jianhao',
                            isResetButton: key === 'o',
                            initialPos: coords.initialPos || null,
                            linkToJianhao: coords.linkToJianhao || false,
                            hasAnimation: coords.hasAnimation || false
                        };
                        
                        // 为yh模型添加额外的视觉效果类
                        if (key === 'yh') {
                            model.classList = ['floating', 'color-pulse'];
                        }
                        
                        if (coords.draggable || DRAGGABLE_MODELS.includes(key)) {
                            clickableObjects.push(model);
                            
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        draggable: coords.draggable || false,
                                        parentModel: model,
                                        type: key,
                                        isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                        isNewModel: NEW_MODELS.includes(key),
                                        isResetButton: key === 'o'
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        } else if (key === 'o') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        parentModel: model,
                                        type: key,
                                        isResetButton: true
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        model.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                if (key === 'o') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0xffff00,
                                        roughness: 0.5,
                                        metalness: 0.3,
                                        emissive: color || 0xffff00,
                                        emissiveIntensity: 0.2
                                    });
                                }
                                else if (key === 'jianhao') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0x87CEEB,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                    child.userData.type = 'jianhao';
                                    child.userData.isJianhao = true;
                                    clickableObjects.push(child);
                                } 
                                else if (key === 'oreo') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0x8B4513,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                }
                                else if (key === 'caomei') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xff3838,
                                        roughness: 0.3,
                                        metalness: 0.2,
                                        emissive: 0x330000,
                                        emissiveIntensity: 0.3
                                    });
                                }
                                else if (key === 'lanmei') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0x0a2463,
                                        roughness: 0.3,
                                        metalness: 0.2,
                                        emissive: 0x000033,
                                        emissiveIntensity: 0.3
                                    });
                                }
                                else if (key === 'b') {
                                    const lightPink = 0xffd1dc;
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: lightPink,
                                        roughness: 0.1,
                                        metalness: 0.5,
                                        emissive: lightPink,
                                        emissiveIntensity: 0.6
                                    });
                                }
                                // 为yh模型添加特殊材质效果（粉色）
                                else if (key === 'yh') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xffb6c1, // 粉色主体
                                        roughness: 6,
                                        metalness: 0.1,
                                        emissive: 0xffb6c1, // 粉色发光
                                        emissiveIntensity: 0.5
                                    });
                                }
                                else if (!child.material || !child.material.map) {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xaaaaaa,
                                        roughness: 0.7,
                                        metalness: 0.1
                                    });
                                }
                            }
                        });
                        
                        scene.add(model);
                        models[key].obj = model;
                        models[key].loaded = true;

                        loaded++;
                        updateProgress(loaded / total);
                        if (loaded === total) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    },
                    (xhr) => {
                        const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
                        document.getElementById('status').textContent = `${getModelName(key)}模型: ${pct}%`;
                        updateProgress(xhr.loaded / xhr.total);
                    },
                    (err) => {
                        console.error(`${getModelName(key)}模型加载失败:`, err);
                        let geom, geomSize = 1;
                        let geomColor = 0xaaaaaa;
                        
                        if (key === 'o') {
                            geom = new THREE.SphereGeometry(geomSize, 32, 32);
                            geomColor = 0xffff00;
                        }
                        else if (key === 'zisedangao') {
                            geom = new THREE.BoxGeometry(3, 3, 3);
                            geomColor = 0x9370db;
                        } else if (key === 'fensedangao') {
                            geom = new THREE.BoxGeometry(5, 5, 5);
                            geomColor = 0xffc0cb;
                        } else if (key === 'cake') {
                            geom = new THREE.BoxGeometry(5, 5, 5);
                            geomColor = 0xcccccc;
                        } else if (key === 'jianhao') {
                            geom = new THREE.BoxGeometry(2, 2, 2);
                            geomColor = 0x87CEEB;
                        } else if (key === 'caomei') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff3838;
                        } else if (key === 'lanmei') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0x2a45ff;
                        } else if (key === 'oreo') {
                            geom = new THREE.BoxGeometry(1 * 0.3, 1 * 0.3, 1 * 0.3);
                            geomColor = 0x8B4513;
                        } else if (key === 'yingtao') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff6347;
                        } else if (key === 'a') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff9900;
                        } else if (key === 'b') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xffd1dc;
                        } else if (key === 'c') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff33cc;
                        } else if (key === 'yh') { // yh模型的备用几何体（粉色）
                            geom = new THREE.BoxGeometry(2, 2, 2);
                            geomColor = 0xffe4e1; // 粉色备用色
                        }
                        else {
                            geom = new THREE.BoxGeometry(geomSize, geomSize, geomSize);
                        }
                        
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: geomColor, 
                            wireframe: true,
                            transparent: true,
                            opacity: 0.8
                        });
                        const model = new THREE.Mesh(geom, mat);
                        
                        model.userData = {
                            type: key,
                            draggable: MODEL_COORDINATES[key].draggable || false,
                            isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                            isNewModel: NEW_MODELS.includes(key),
                            isJianhao: key === 'jianhao',
                            isResetButton: key === 'o',
                            initialPos: MODEL_COORDINATES[key].initialPos || null,
                            linkToJianhao: MODEL_COORDINATES[key].linkToJianhao || false,
                            hasAnimation: MODEL_COORDINATES[key].hasAnimation || false
                        };
                        
                        if (rotation) {
                            model.rotation.set(rotation.x, rotation.y, rotation.z);
                        }
                        
                        if (MODEL_COORDINATES[key].draggable || DRAGGABLE_MODELS.includes(key)) {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        draggable: MODEL_COORDINATES[key].draggable || false,
                                        parentModel: model,
                                        type: key,
                                        isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                        isNewModel: NEW_MODELS.includes(key)
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        } else if (key === 'o') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        parentModel: model,
                                        type: key,
                                        isResetButton: true
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        if (key === 'jianhao') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData.isJianhao = true;
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        model.position.set(x, y, z);
                        model.scale.set(scale, scale, scale);
                        model.visible = visible;
                        scene.add(model);
                        
                        models[key].obj = model;
                        models[key].loaded = true;
                        loaded++;
                        updateProgress(loaded / total);
                        
                        if (loaded === total) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    }
                );
            }

            // 辅助函数
            function isAtInitialPosition(modelKey) {
                const model = models[modelKey];
                if (!model || !model.obj || !model.initialPos) return false;
                
                const currentPos = model.obj.position;
                const initialPos = model.initialPos;
                
                const xMatch = Math.abs(currentPos.x - initialPos.x) <= POSITION_TOLERANCE;
                const yMatch = Math.abs(currentPos.y - initialPos.y) <= POSITION_TOLERANCE;
                const zMatch = Math.abs(currentPos.z - initialPos.z) <= POSITION_TOLERANCE;
                
                return xMatch && yMatch && zMatch;
            }

            function updateFruitsAfterConfirmation() {
                DRAGGABLE_MODELS.filter(key => !NEW_MODELS.includes(key)).forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    const atInitialPos = isAtInitialPosition(modelKey);
                    model.obj.visible = !atInitialPos;
                    model.visible = !atInitialPos;
                    model.obj.userData.draggable = false;
                    model.isConfirmed = true;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = false;
                        }
                    });
                });
                
                NEW_MODELS.forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    model.obj.visible = true;
                    model.visible = true;
                    model.obj.userData.draggable = true;
                    model.isConfirmed = false;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = true;
                        }
                    });
                });
                
                tooltip.style.opacity = 1;
                tooltip.textContent = '模型A、B、C已显示，可点击拖动它们';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 3000);
            }

            function finalizeNewModels() {
                NEW_MODELS.forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    const atInitialPos = isAtInitialPosition(modelKey);
                    
                    model.obj.visible = !atInitialPos;
                    model.visible = !atInitialPos;
                    model.obj.userData.draggable = false;
                    model.isConfirmed = true;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = false;
                        }
                    });
                });
                
                tooltip.style.opacity = 1;
                tooltip.textContent = '已确认最终状态：移动过的模型保留，未移动的模型已隐藏';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 3000);
                
                showExcellent();
            }

            // 重置当前3D场景状态
            function resetCurrentSession() {
                jianhaoClicked = false;
                jianhaoConfirmed = false;
                jianhaoFinalized = false;
                jianhaoPermanentlyHidden = false;
                draggedObject = null;
                isDraggingModel = false;
                isRotatingView = false;
                isCameraAnimating = false;
                
                // 停止yh模型动画
                if (mixer) {
                    mixer.stopAllAction();
                }
                
                if (excellentText) {
                    excellentText.style.opacity = 0;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.9)';
                }
                
                Object.keys(MODEL_COORDINATES).forEach(key => {
                    const coords = MODEL_COORDINATES[key];
                    const model = models[key];
                    
                    if (model && model.obj) {
                        model.obj.position.set(
                            coords.position.x,
                            coords.position.y,
                            coords.position.z
                        );
                        
                        if (coords.rotation) {
                            model.obj.rotation.set(
                                coords.rotation.x,
                                coords.rotation.y,
                                coords.rotation.z
                            );
                        } else {
                            model.obj.rotation.set(0, 0, 0);
                        }
                        
                        model.obj.visible = coords.visible;
                        model.visible = coords.visible;
                        
                        const isDraggable = coords.draggable || DRAGGABLE_MODELS.includes(key);
                        model.obj.userData.draggable = isDraggable;
                        model.isConfirmed = false;
                        
                        model.obj.traverse(child => {
                            if (child.isMesh) {
                                child.userData.draggable = isDraggable;
                            }
                        });
                    }
                });
                
                spheres.forEach(sphere => {
                    if (sphere.mesh) {
                        sphere.mesh.visible = true;
                    }
                });
                
                if (camera && controls) {
                    camera.position.set(0, 15, 30);
                    controls.target.set(0, 1, 0);
                    controls.reset();
                    controls.enabled = true;
                }
                
                tooltip.style.opacity = 1;
                tooltip.textContent = '已重置当前会话';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 2000);
            }

            // 事件处理函数
            function onMouseDown(event) {
                if (isCameraAnimating) return;
                
                if (jianhaoPermanentlyHidden) {
                    const tempClickableObjects = clickableObjects.filter(obj => 
                        !(obj.userData.isJianhao || obj.userData.type === 'o' || 
                          (obj.parent && (obj.parent.userData.isJianhao || obj.parent.userData.type === 'o')))
                    );
                }
                
                event.preventDefault();
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(clickableObjects, true);
                
                isDraggingModel = false;
                isRotatingView = false;
                draggedObject = null;
                
                let clickedResetButton = false;
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    clickedResetButton = obj.userData.isResetButton || 
                                      (obj.parent && obj.parent.userData.isResetButton);
                    
                    if (clickedResetButton) {
                        resetCurrentSession();
                        return;
                    }
                }
                
                let clickedJianhao = false;
                if (!jianhaoPermanentlyHidden && intersects.length > 0) {
                    const obj = intersects[0].object;
                    clickedJianhao = obj.userData.isJianhao || 
                                    (obj.parent && obj.parent.userData.isJianhao);
                }
                
                if (clickedJianhao) {
                    if (!jianhaoClicked) {
                        jianhaoClicked = true;
                        jianhaoConfirmed = false;
                        jianhaoFinalized = false;
                        spheres.forEach(sphere => sphere.mesh && (sphere.mesh.visible = false));
                        
                        DRAGGABLE_MODELS.forEach(modelKey => {
                            const isNew = NEW_MODELS.includes(modelKey);
                            setModelVisibility(modelKey, !isNew);
                            
                            if (models[modelKey] && models[modelKey].obj) {
                                models[modelKey].obj.userData.draggable = !isNew;
                                models[modelKey].obj.traverse(child => {
                                    if (child.isMesh) child.userData.draggable = !isNew;
                                });
                                models[modelKey].isConfirmed = false;
                            }
                        });
                        
                        tooltip.style.opacity = 1;
                        tooltip.textContent = '拖动水果调整位置，再次点击加号确认';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                        return;
                    } else if (!jianhaoConfirmed) {
                        jianhaoConfirmed = true;
                        jianhaoFinalized = false;
                        updateFruitsAfterConfirmation();
                        return;
                    } else if (!jianhaoFinalized) {
                        jianhaoFinalized = true;
                        finalizeNewModels();
                        return;
                    } else {
                        jianhaoFinalized = false;
                        jianhaoConfirmed = false;
                        
                        if (models.jianhao && models.jianhao.obj) {
                            models.jianhao.obj.visible = true;
                        }
                        if (models.o && models.o.obj) {
                            models.o.obj.visible = true;
                        }
                        
                        DRAGGABLE_MODELS.forEach(modelKey => {
                            setModelVisibility(modelKey, true);
                            if (models[modelKey] && models[modelKey].obj) {
                                models[modelKey].obj.userData.draggable = true;
                                models[modelKey].obj.traverse(child => {
                                    if (child.isMesh) child.userData.draggable = true;
                                });
                                models[modelKey].isConfirmed = false;
                            }
                        });
                        
                        tooltip.style.opacity = 1;
                        tooltip.textContent = '可重新调整所有模型位置，再次点击加号确认';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                        return;
                    }
                }
                
                if (!jianhaoClicked && intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    if (clickedObject.userData.isSphere) {
                        switch (clickedObject.userData.type) {
                            case 'showCake':
                                setModelVisibility('cake', true);
                                setModelVisibility('zisedangao', false);
                                setModelVisibility('fensedangao', false);
                                break;
                            case 'showFenSe':
                                setModelVisibility('cake', false);
                                setModelVisibility('zisedangao', false);
                                setModelVisibility('fensedangao', true);
                                break;
                            case 'showZiSe':
                                setModelVisibility('cake', false);
                                setModelVisibility('zisedangao', true);
                                setModelVisibility('fensedangao', false);
                                break;
                        }
                        return;
                    }
                }
                
                if (!jianhaoFinalized && intersects.length > 0) {
                    for (let i = 0; i < intersects.length; i++) {
                        const intersect = intersects[i];
                        let targetObject = intersect.object;
                        
                        if (targetObject.userData.type === 'o' || 
                            (targetObject.parent && targetObject.parent.userData.type === 'o')) {
                            continue;
                        }
                        
                        if (targetObject.userData.draggable || 
                           (targetObject.parent && targetObject.parent.userData.draggable)) {
                            
                            draggedObject = targetObject.userData.parentModel || targetObject;
                        }
                        
                        if (draggedObject) {
                            isDraggingModel = true;
                            controls.enabled = false;
                            
                            const plane = new THREE.Plane();
                            plane.setFromNormalAndCoplanarPoint(
                                camera.getWorldDirection(new THREE.Vector3()),
                                draggedObject.getWorldPosition(new THREE.Vector3())
                            );
                            
                            const intersectionPoint = new THREE.Vector3();
                            raycaster.ray.intersectPlane(plane, intersectionPoint);
                            
                            dragOffset.copy(draggedObject.getWorldPosition(new THREE.Vector3()))
                                  .sub(intersectionPoint);
                            
                            document.body.style.cursor = 'grabbing';
                            break;
                        }
                    }
                }
                
                if (!draggedObject && !clickedJianhao) {
                    isRotatingView = true;
                    controls.enabled = true;
                    document.body.style.cursor = 'grabbing';
                }
            }

            function onMouseMove(event) {
                if (isCameraAnimating) return;
                
                event.preventDefault();
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (!jianhaoFinalized && draggedObject && isDraggingModel) {
                    if (draggedObject.userData.type === 'o' || 
                        (draggedObject.parent && draggedObject.parent.userData.type === 'o')) {
                        return;
                    }
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const plane = new THREE.Plane();
                    plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection(new THREE.Vector3()),
                        draggedObject.getWorldPosition(new THREE.Vector3())
                    );
                    
                    const intersectionPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectionPoint);
                    
                    const newPosition = new THREE.Vector3()
                        .copy(intersectionPoint)
                        .add(dragOffset);
                    
                    if (draggedObject.userData.alwaysDraggable) {
                        draggedObject.position.copy(newPosition);
                    } else {
                        newPosition.y = Math.max(newPosition.y, -1.8);
                        draggedObject.position.copy(newPosition);
                    }
                    return;
                }
                
                if (!jianhaoClicked) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(clickableObjects, false);
                    
                    let hoveredSphere = null;
                    let tooltipText = '';
                    
                    for (let i = 0; i < intersects.length; i++) {
                        if (intersects[i].object.userData.isSphere) {
                            for (let j = 0; j < spheres.length; j++) {
                                if (spheres[j].mesh === intersects[i].object) {
                                    hoveredSphere = spheres[j];
                                    tooltipText = spheres[j].tooltip;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    
                    if (hoveredSphere) {
                        tooltip.style.opacity = 1;
                        tooltip.textContent = tooltipText;
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                    } else {
                        tooltip.style.opacity = 0;
                    }
                } else if (!jianhaoFinalized) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(clickableObjects, true);
                    let isHoveringDraggable = false;
                    
                    for (let i = 0; i < intersects.length; i++) {
                        const obj = intersects[i].object;
                        if (obj.userData.type === 'o' || (obj.parent && obj.parent.userData.type === 'o')) {
                            continue;
                        }
                        
                        if (obj.userData.draggable || 
                           (obj.parent && obj.parent.userData.draggable)) {
                            isHoveringDraggable = true;
                            break;
                        }
                    }
                    
                    if (isHoveringDraggable) {
                        tooltip.style.opacity = 1;
                        tooltip.textContent = '点击并拖动调整位置';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                    } else if (!draggedObject) {
                        tooltip.style.opacity = 0;
                    }
                } else {
                    tooltip.style.opacity = 0;
                }
            }

            function onMouseUp() {
                if (isCameraAnimating) return;
                
                if (draggedObject) {
                    draggedObject = null;
                    isDraggingModel = false;
                }
                
                isRotatingView = false;
                controls.enabled = true;
                document.body.style.cursor = 'default';
            }

            // 工具函数
            function setModelVisibility(modelKey, visible) {
                if (modelKey === 'jianhao' && jianhaoPermanentlyHidden) {
                    if (models.o && models.o.obj) {
                        models.o.obj.visible = false;
                    }
                    return;
                }
                
                if (modelKey === 'o' && models.o.linkToJianhao) {
                    visible = models.jianhao ? models.jianhao.visible : false;
                }
                
                if (models[modelKey] && models[modelKey].obj) {
                    models[modelKey].obj.visible = visible;
                    models[modelKey].visible = visible;
                    
                    if (modelKey === 'jianhao' && models.o && models.o.obj && models.o.linkToJianhao) {
                        models.o.obj.visible = visible;
                        models.o.visible = visible;
                    }
                }
            }

            function updateProgress(ratio) {
                const pct = Math.round(ratio * 100);
                document.getElementById('progress-bar').style.width = pct + '%';
            }

            function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                
                // 更新动画混合器（如果存在）
                if (mixer) {
                    mixer.update(0.016); // 假设60fps
                }
                
                renderer.render(scene, camera);
            }

            // 启动3D初始化
            init();
            
        }
        // 背景随鼠标轻微偏移 + 缩放
        document.addEventListener("mousemove", (e) => {
            const moveX = (e.clientX / window.innerWidth - 0.5) * 10;
            const moveY = (e.clientY / window.innerHeight - 0.5) * 10;
            const scale = 1.02 + Math.abs(moveX) / 200 + Math.abs(moveY) / 200; 

            const overlay = document.getElementById("overlay");
            if (overlay) {
                overlay.style.backgroundPosition = `${50 + moveX}% ${50 + moveY}%`;
                overlay.style.transform = `scale(${scale})`;
            }
        });

        // 页面大小改变
        window.addEventListener('resize', () => {
            if (typeof camera !== 'undefined' && typeof renderer !== 'undefined') {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Bubble & Excellent Particles Enhancements
        (function(){
            const overlay = document.getElementById('overlay');
            const bubbleContainer = document.getElementById('bubble-container');
            const excellentText = document.getElementById('excellent-text');
            const restartOverlay = document.getElementById('restart-overlay');
            let bubbleInterval = null;

            function spawnBubble(){
                if (!overlay || overlay.classList.contains('hidden')) return;
                const b = document.createElement('div');
                b.className = 'bubble';
                const size = Math.round(30 + Math.random() * 50);
                b.style.width = size + 'px';
                b.style.height = size + 'px';
                b.style.left = (8 + Math.random() * 84) + '%';
                b.style.top = (60 + Math.random() * 30) + '%';
                const dur = (6 + Math.random() * 6).toFixed(2);
                b.style.animationDuration = dur + 's';
                bubbleContainer.appendChild(b);
                setTimeout(()=> b.remove(), (parseFloat(dur)+0.6)*1000);
            }
            function startBubbleSpawn(){
                if (bubbleInterval) return;
                bubbleInterval = setInterval(()=>{
                    if (overlay && !overlay.classList.contains('hidden')) spawnBubble();
                }, 800);
            }
            function stopBubbleSpawn(){
                if (bubbleInterval){ clearInterval(bubbleInterval); bubbleInterval=null; }
            }

            // Excellent 粒子
            function spawnDomParticleAt(el){
                const rect = el.getBoundingClientRect();
                const p = document.createElement('div');
                p.className = 'particle-dom';
                const offsetX = (Math.random() - 0.5) * 120;
                const offsetY = (Math.random() - 0.5) * 40;
                p.style.left = (rect.left + rect.width/2 + offsetX) + 'px';
                p.style.top = (rect.top + rect.height/2 + offsetY) + 'px';
                p.style.width = (14 + Math.random()*26) + 'px';
                p.style.height = p.style.width;
                document.body.appendChild(p);
                setTimeout(()=> p.remove(), 1200);
            }
            function spawnExcellentParticles(){
                if (!excellentText) return;
                for (let i=0;i<26;i++){
                    setTimeout(()=> spawnDomParticleAt(excellentText), i*30);
                }
            }

            // 替换原 showExcellent
            if (typeof showExcellent === 'function'){
                const _orig = showExcellent;
                showExcellent = function(){
                    _orig();
                    spawnExcellentParticles();
                };
            }

            // 页面一开始启动泡泡
            startBubbleSpawn();
        })();

        // 视差滚动效果
        document.addEventListener("mousemove", (e) => {
            const moveX = (e.clientX / window.innerWidth - 0.5);
            const moveY = (e.clientY / window.innerHeight - 0.5);

            const bg = document.querySelector(".layer-bg");
            const mid = document.querySelector(".layer-mid");
            const fg = document.querySelector(".layer-fg");

            if (bg) bg.style.transform = `translate(${moveX * 10}px, ${moveY * 10}px)`;
            if (mid) mid.style.transform = `translate(${moveX * 20}px, ${moveY * 20}px)`;
            if (fg) fg.style.transform = `translate(${moveX * 40}px, ${moveY * 40}px)`;
        });
    </script>

    <!-- 增强效果 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
    // 增强脚本
    (function(){
        function whenReady(cb){
            const start = performance.now();
            (function poll(){
                if (typeof scene !== 'undefined' && typeof camera !== 'undefined' && typeof renderer !== 'undefined') {
                    try { cb(); } catch(e){ console.error('enhance cb failed', e); }
                } else if (performance.now() - start < 8000) {
                    requestAnimationFrame(poll);
                } else {
                    console.warn('enhance: three core objects not found in time; initialization aborted.');
                }
            })();
        }

        whenReady(function(){
            // 后期处理
            let composer, renderPass, bloomPass;
            function initComposer(){
                try {
                    renderPass = new THREE.RenderPass(scene, camera);
                    bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.2);
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderPass);
                    composer.addPass(bloomPass);
                    window._enh_composer = composer;
                    window._enh_bloomPass = bloomPass;
                } catch (e) {
                    console.warn('initComposer failed', e);
                }
            }
            initComposer();

            // 发光效果
            function setObjectBloom(obj, enable=true){
                if (!obj) return;
                obj.traverse(c => {
                    if (c.isMesh) {
                        if (enable) c.layers.enable(1);
                        else c.layers.disable(1);
                    }
                });
            }
            window.setObjectBloom = setObjectBloom;

            // 粒子效果
            const particlePool = { points: null, positions: null, velocities: null, count: 0, max: 300 };
            function makeCircleTexture(color){
                const size = 64;
                const cvs = document.createElement('canvas');
                cvs.width = cvs.height = size;
                const ctx = cvs.getContext('2d');
                ctx.clearRect(0,0,size,size);
                const g = ctx.createRadialGradient(size/2, size/2, 1, size/2, size/2, size/2);
                g.addColorStop(0, color);
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2, 0, Math.PI*2);
                ctx.fill();
                const tex = new THREE.CanvasTexture(cvs);
                tex.needsUpdate = true;
                return tex;
            }

            function initParticlePool(){
                if (!scene) return;
                const max = particlePool.max;
                const geom = new THREE.BufferGeometry();
                const positions = new Float32Array(max * 3);
                const velocities = new Float32Array(max * 3);
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.35 * (window.devicePixelRatio || 1),
                    map: makeCircleTexture('rgba(255,150,200,0.95)'),
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                const points = new THREE.Points(geom, mat);
                points.frustumCulled = false;
                points.renderOrder = 9999;
                scene.add(points);
                particlePool.points = points;
                particlePool.positions = positions;
                particlePool.velocities = velocities;
                particlePool.count = 0;
            }
            initParticlePool();

            function spawnParticlesAtWorld(pos, opts){
                if (!particlePool.points) return;
                opts = Object.assign({ count: 18, spread: 0.8 }, opts || {});
                const available = particlePool.max - particlePool.count;
                const c = Math.min(opts.count, available);
                if (c <= 0) return;
                const base = particlePool.count;
                for (let i=0;i<c;i++){
                    const idx = base + i;
                    const px = pos.x + (Math.random()-0.5) * opts.spread;
                    const py = pos.y + (Math.random()*0.8);
                    const pz = pos.z + (Math.random()-0.5) * opts.spread;
                    particlePool.positions[3*idx] = px;
                    particlePool.positions[3*idx+1] = py;
                    particlePool.positions[3*idx+2] = pz;
                    particlePool.velocities[3*idx] = (Math.random()-0.5) * 0.12;
                    particlePool.velocities[3*idx+1] = 0.15 + Math.random()*0.25;
                    particlePool.velocities[3*idx+2] = (Math.random()-0.5) * 0.12;
                }
                particlePool.count += c;
                particlePool.points.geometry.setDrawRange(0, particlePool.count);
                particlePool.points.geometry.attributes.position.needsUpdate = true;
                setTimeout(() => {
                    particlePool.count = Math.max(0, particlePool.count - Math.floor(c/1.2));
                }, 900);
            }
            window._spawnParticlesAtWorld = spawnParticlesAtWorld;

            // 动画增强
            const originalAnimateRef = window.animate || function(){ requestAnimationFrame(arguments.callee); };
            function animateEnhancer(){
                requestAnimationFrame(animateEnhancer);
                try {
                    // 更新粒子
                    if (particlePool.points && particlePool.count > 0){
                        for (let i=0;i<particlePool.count;i++){
                            particlePool.positions[3*i] += particlePool.velocities[3*i];
                            particlePool.positions[3*i+1] += particlePool.velocities[3*i+1];
                            particlePool.positions[3*i+2] += particlePool.velocities[3*i+2];
                            particlePool.velocities[3*i+1] -= 0.007;
                        }
                        particlePool.points.geometry.attributes.position.needsUpdate = true;
                    }
                } catch(e){ console.warn('animateEnhancer error', e); }
                // 渲染
                try {
                    if (window._enh_composer && window._enh_bloomPass){
                        camera.layers.set(1);
                        renderer.autoClear = true;
                        window._enh_composer.render();

                        camera.layers.set(0);
                        renderer.render(scene, camera);
                    } else {
                        renderer.render(scene, camera);
                    }
                } catch(e){ console.warn('enhanced render error', e); }
            }
            animateEnhancer();

            // 相机移动
            function gsapMoveCameraTo(x,y,z, dur, cb){
                if (typeof gsap === 'undefined') {
                    camera.position.set(x,y,z);
                    if (cb) cb();
                    return;
                }
                gsap.to(camera.position, {
                    x:x, y:y, z:z, duration: dur || 1.2, ease: 'power2.inOut',
                    onUpdate: function(){ camera.lookAt(0,1,0); },
                    onComplete: cb
                });
            }
            window._enh_gsapMoveCameraTo = gsapMoveCameraTo;

            function onFinalizeMagic(){
                try {
                    if (models && models.cake && models.cake.obj){
                        const c = models.cake.obj;
                        if (typeof gsap !== 'undefined'){
                            gsap.fromTo(c.scale, {x:0.86,y:0.86,z:0.86}, {x:1.02,y:1.02,z:1.02, duration:0.65, ease:'elastic.out(1,0.6)'});
                        } else {
                            c.scale.set(1.02,1.02,1.02);
                            setTimeout(()=>c.scale.set(1,1,1), 650);
                        }
                        setObjectBloom(c, true);
                        setTimeout(()=> setObjectBloom(c, false), 900);
                        const wp = new THREE.Vector3();
                        c.getWorldPosition(wp);
                        spawnParticlesAtWorld(wp, { count: 36, spread: 1.4 });
                        gsapMoveCameraTo(0, 11, 18, 1.1, ()=> gsapMoveCameraTo(0,15,30,1.0));
                    }
                } catch(e){ console.warn('onFinalizeMagic failed', e); }
            }
            if (typeof finalizeNewModels === 'function'){
                const _orig = finalizeNewModels;
                finalizeNewModels = function(){
                    _orig();
                    try { onFinalizeMagic(); } catch(e){ console.warn(e); }
                };
            } else {
                window.finalizeNewModels = onFinalizeMagic;
            }

            // 拖动结束效果
            const _origMouseUp = window.onMouseUp || null;
            window.onMouseUp = function(){
                try {
                    if (typeof draggedObject !== 'undefined' && draggedObject){
                        try {
                            const wp = new THREE.Vector3();
                            draggedObject.getWorldPosition(wp);
                            spawnParticlesAtWorld(wp, { count: 12, spread: 0.6 });
                            setObjectBloom(draggedObject, true);
                            setTimeout(()=> setObjectBloom(draggedObject, false), 700);
                        } catch(e){}
                    }
                } catch(e){ console.warn(e); }
                if (typeof _origMouseUp === 'function') _origMouseUp();
            };

            // 响应式处理
            window.addEventListener('resize', function(){
                try {
                    if (window._enh_composer){
                        window._enh_composer.setSize(window.innerWidth, window.innerHeight);
                    }
                } catch(e){}
            });

            console.log('Enhancer initialized: bloom, particles, GSAP hooks');
        });
    })();
    </script>
</body>
</html>

