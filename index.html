<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cakeæ¨¡å‹æŸ¥çœ‹å™¨ï¼ˆå¸¦çƒŸèŠ±åŠ¨ç”»ï¼‰</title>
    <style>
        /* åˆå§‹è¦†ç›–å±‚æ ·å¼ */
#overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: url("images/cake-bg.jpg") no-repeat center center;
    background-size: cover;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    transition: opacity 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), 
                visibility 0.8s, 
                background-position 0.2s ease, 
                transform 0.2s ease;
    visibility: visible;
    opacity: 1;
}

        /* é‡å¯è¦†ç›–å±‚ */
        #restart-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #ffecef 0%, #fff9e6 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9998;
            transition: opacity 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), visibility 0.8s;
            visibility: hidden;
            opacity: 0;
        }

        /* è‰ºæœ¯å‘å…‰æ ‡é¢˜æ ·å¼ */
        #fantasy-title {
    margin-bottom: 2rem;
    display: inline-block;
    animation: titlePulse 3s infinite alternate;
}

#fantasy-title img {
    width: 1000px;
    height: auto;
    display: block;
}

      @keyframes titlePulse {
    0% {
        transform: scale(0.95);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(0.95);
    }
}  

        /* StartæŒ‰é’®æ ·å¼ */
        #overlay {
    width: 100%;
    height: 100%;
    overflow: visible;
}

#start-btn {
    padding: 0;
    border: none;
    background: transparent;
    cursor: pointer;
    outline: none;
    animation: bounceGlow 2s infinite ease-in-out;
    display: inline-block;
}

#start-btn img {
    display: block;
    width: 200px !important;
    height: auto;
    pointer-events: none;
} 

#start-btn img {
    display: block;
    width: 120px;
    height: auto;
    pointer-events: none;
}

        /* RestartæŒ‰é’®æ ·å¼ */
        #restart-btn {
            padding: 1.2rem 3.5rem;
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Arial', sans-serif;
            background-color: #ff6b9e;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 
                0 6px 20px rgba(255, 107, 158, 0.5),
                inset 0 -3px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            outline: none;
            transform: scale(1);
            animation: buttonPulse 2s infinite alternate;
        }

        /* è¦†ç›–å±‚éšè—çŠ¶æ€ */
        #overlay.hidden, #restart-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* è¦†ç›–å±‚æ˜¾ç¤ºçŠ¶æ€ */
        #restart-overlay.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* åŸæœ‰æ ·å¼ä¿æŒä¸å˜ */
        body { 
            margin: 0; 
            overflow: hidden; 
           
        }
        #container { width: 100%; height: 100vh; }
        #loading { 
            display: none; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            background: rgba(255,255,255,0.8);
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #progress { width: 300px; height: 20px; border: 1px solid #ddd; margin: 10px 0; border-radius: 10px; overflow: hidden; }
        #progress-bar { height: 100%; background: linear-gradient(90deg, #ff69b4, #4fc3f7); width: 0%; }
        #status { color: #333; font-size: 14px; }
        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .draggingæç¤º {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0.7;
        }
        #excellent-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6rem;
            font-weight: 900;
            font-family: 'Arial Black', Impact, sans-serif;
            text-transform: uppercase;
            letter-spacing: -2px;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            background: linear-gradient(135deg, #9370db 0%, #4fc3f7 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 
                0 0 10px rgba(147, 112, 219, 0.7),
                0 0 20px rgba(147, 112, 219, 0.5),
                0 0 30px rgba(79, 195, 247, 0.5),
                0 0 40px rgba(79, 195, 247, 0.3),
                0 2px 5px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -50%) rotate(-2deg) scale(0.9);
            pointer-events: none;
            z-index: 1000;
            animation: pulse 2s infinite alternate;
        }
        @keyframes pulse {
            0% {
                text-shadow: 
                    0 0 10px rgba(147, 112, 219, 0.7),
                    0 0 20px rgba(147, 112, 219, 0.5),
                    0 0 30px rgba(79, 195, 247, 0.5),
                    0 0 40px rgba(79, 195, 247, 0.3);
                transform: translate(-50%, -50%) rotate(-2deg) scale(0.9);
            }
            100% {
                text-shadow: 
                    0 0 15px rgba(147, 112, 219, 0.9),
                    0 0 30px rgba(147, 112, 219, 0.7),
                    0 0 45px rgba(79, 195, 247, 0.7),
                    0 0 60px rgba(79, 195, 247, 0.5);
                transform: translate(-50%, -50%) rotate(-2deg) scale(1);
            }
        }
    
        /* ç²’å­å®¹å™¨ */
        #cute-effects {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            font-size: 20px;
            animation: floatDown 6s linear;
            opacity: 0.9;
            transform: translateY(-20%);
            will-change: transform, opacity;
        }
        @keyframes floatDown {
            0% { transform: translateY(-10%) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110%) rotate(360deg); opacity: 0; }
        }
        #music-btn {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 50px;
    height: 50px;
    border: none;
    background: transparent;
    cursor: pointer;
    z-index: 2000;
    padding: 0;
}

#music-btn img {
    width: 100%;
    height: 100%;
    display: block;
}

        
</style>
</head>
<body>
    <!-- åˆå§‹è¦†ç›–å±‚ -->
    <div id="overlay">
    <h1 id="fantasy-title">
        <img src="images/my-title.png" alt="Fantasy Cake" />
    </h1>

    <button id="start-btn">
        <img src="images/start-icon.png" alt="Start" />
    </button>

    <!-- æ–°å¢éŸ³ä¹æŒ‰é’® -->
    <button id="music-btn">
        <img id="music-icon" src="images/music-on.png" alt="éŸ³ä¹å¼€å…³">
    </button>

    <div id="cute-effects"></div>
</div>
    <!-- é‡å¯è¦†ç›–å±‚ -->
    <div id="restart-overlay">
        <button id="restart-btn">Restart</button>
    </div>

    <!-- 3Då†…å®¹å®¹å™¨ -->
    <div id="container"></div>
    <div id="loading">
        <h3 style="color: #333; margin-top: 0;">åŠ è½½ä¸­...</h3>
        <div id="progress"><div id="progress-bar"></div></div>
        <div id="status">å°è›‹ç³•å‡†å¤‡ä¸­...</div>
    </div>
    <!-- BGM æ§åˆ¶æŒ‰é’®ï¼ˆå·¦ä¸Šè§’ï¼‰ -->
<button id="music-btn">
    <img id="music-icon" src="images/music-on.png" alt="éŸ³ä¹å¼€å…³">
</button>

<!-- å…¨å±€ BGM éŸ³é¢‘ -->
<audio id="bgm" src="audio/bgm.mp3" loop></audio>
    <div class="tooltip"></div>
    <div class="draggingæç¤º">æ‹–åŠ¨è£…é¥°ç‰©æ¥è£…é¥°ä½ çš„å°è›‹ç³•å§~</div>
    <div id="excellent-text">excellentï¼</div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <!-- æ–°å¢ï¼šåŠ è½½åŠ¨ç”»æ§åˆ¶å™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/animation/AnimationMixer.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let threeJsInitialized = false;
        // æ–°å¢ï¼šåŠ¨ç”»æ··åˆå™¨å˜é‡
        let animationMixers = {};
        let clock = new THREE.Clock();
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('overlay');
            const startBtn = document.getElementById('start-btn');
            const restartOverlay = document.getElementById('restart-overlay');
            const restartBtn = document.getElementById('restart-btn');
            const loading = document.getElementById('loading');
            const cuteEffects = document.getElementById('cute-effects');
            
    // BGM æ§åˆ¶é€»è¾‘
    const musicBtn = document.getElementById('music-btn');
    const musicIcon = document.getElementById('music-icon');
    const bgm = document.getElementById('bgm');
    let isPlaying = false;

    musicBtn.addEventListener('click', () => {
    if (isPlaying) {
        bgm.pause();
        isPlaying = false;
    } else {
        bgm.play().catch(err => console.log('BGMæ’­æ”¾å¤±è´¥', err));
        isPlaying = true;
    }
});

            // ç‚¹å‡» Start æŒ‰é’®
startBtn.addEventListener('click', function () {
    overlay.classList.add('hidden');
    loading.style.display = 'block';
    bgm.play().catch(err => console.log('BGMæ’­æ”¾å¤±è´¥', err));

    document.body.style.background = "url('images/game-bg.jpg') no-repeat center center / cover";

    setTimeout(init3DCakeViewer, 500);
});
            

            // åˆå§‹é¡µé¢èƒŒæ™¯éšé¼ æ ‡è½»å¾®åç§»
            document.addEventListener('mousemove', (e) => {
                const overlayEl = document.getElementById('overlay');
                if (!overlayEl || overlayEl.classList.contains('hidden')) return;
                const moveX = (e.clientX / window.innerWidth - 0.5) * 10;
                const moveY = (e.clientY / window.innerHeight - 0.5) * 10;
                overlayEl.style.backgroundPosition = `${50 + moveX}% ${50 + moveY}%`;
                const scale = 1.02 + (Math.abs(moveX) + Math.abs(moveY)) / 400;
                overlayEl.style.transform = `scale(${scale})`;
            });

            // éšæœºç”Ÿæˆå¯çˆ±ç²’å­
            function spawnParticle() {
                const cuteEffects = document.getElementById('cute-effects');
                if (!cuteEffects) return;
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = Math.random() * 100 + '%';
                particle.style.fontSize = (12 + Math.random() * 20) + 'px';
                particle.textContent = Math.random() > 0.5 ? 'â­' : 'ğŸ’–';
                cuteEffects.appendChild(particle);
                const drift = (Math.random() - 0.5) * 30;
                particle.style.transform = `translateX(${drift}px)`;
                setTimeout(() => {
                    particle.remove();
                }, 6200);
            }
            let particleInterval = setInterval(() => {
                const overlayEl = document.getElementById('overlay');
                if (overlayEl && !overlayEl.classList.contains('hidden')) spawnParticle();
            }, 900);

            
            // ç‚¹å‡»RestartæŒ‰é’®
            restartBtn.addEventListener('click', function() {
                restartOverlay.classList.remove('visible');
                restartOverlay.classList.add('hidden');
                fullResetToInitialState();
            });
        });

        // å®Œå…¨é‡ç½®åˆ°é¡µé¢åˆšæ‰“å¼€çš„çŠ¶æ€
        function fullResetToInitialState() {
            // æ¸…é™¤æ‰€æœ‰Three.jså®ä¾‹
            if (scene) {
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            if (renderer && renderer.domElement && renderer.domElement.parentElement) {
                renderer.domElement.parentElement.removeChild(renderer.domElement);
            }
            
            // é‡ç½®åŠ¨ç”»æ··åˆå™¨
            animationMixers = {};
            
            // é‡ç½®æ‰€æœ‰å˜é‡
            scene = null;
            camera = null;
            renderer = null;
            controls = null;
            threeJsInitialized = false;
            
            // æ˜¾ç¤ºåˆå§‹è¦†ç›–å±‚
            const overlay = document.getElementById('overlay');
            overlay.classList.remove('hidden');
            
            // é‡ç½®åŠ è½½çŠ¶æ€
            document.getElementById('loading').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
            document.getElementById('status').textContent = 'å‡†å¤‡åŠ è½½æ¨¡å‹';
            
            // é‡ç½®excellentæ–‡å­—
            const excellentText = document.getElementById('excellent-text');
            excellentText.style.opacity = 0;
        }

        // åˆå§‹åŒ–3Dè›‹ç³•æŸ¥çœ‹å™¨
        function init3DCakeViewer() {
            if (threeJsInitialized) return;
            threeJsInitialized = true;
            
            // æ‰€æœ‰æ¨¡å‹åæ ‡é›†ä¸­é…ç½®åŒºï¼ˆä¼˜åŒ–yanhuaæ¨¡å‹é…ç½®ï¼‰
            const MODEL_COORDINATES = {
                cake: { 
                    position: { x: 0, y: -2, z: 0 },
                    scale: 5,
                    visible: true
                },
                zisedangao: { 
                    position: { x: 4, y: -2, z: -5 },
                    scale: 1.5,
                    visible: false
                },
                fensedangao: { 
                    position: { x: 0, y: 5, z: 0 },
                    scale: 10,
                    visible: false
                },
                jianhao: { 
                    position: { x: 13, y: -6, z: 4 },
                    scale: 2,
                    visible: true,
                    rotation: { x: Math.PI / 3, y: 0, z: 0 },
                    color: 0x87CEEB
                },
                o: { 
                    position: { x: -18, y: -9, z: 5 },
                    scale: 0.17,
                    visible: true,
                    color: 0xffff00,
                    draggable: false,
                    rotation: { x: Math.PI / 3, y: 0, z: 0 },
                    linkToJianhao: true
                },
                caomei: { 
                    position: { x: 8, y: -2, z: 6 },
                    scale: 0.08,
                    visible: false,
                    initialPos: { x: 8, y: -2, z: 6 }
                },
                lanmei: { 
                    position: { x: 3, y: -2, z: 6 },
                    scale: 150,
                    visible: false,
                    initialPos: { x: 3, y: -2, z: 6 }
                },
                oreo: { 
                    position: { x: -3, y: -1.5, z: 6 },
                    scale: 0.3,
                    visible: false,
                    color: 0x8B4513,
                    initialPos: { x: -3, y: -1.5, z: 6 }
                },
                yingtao: { 
                    position: { x: -8, y: -2, z: 6 },
                    scale: 0.8,
                    visible: false,
                    initialPos: { x: -8, y: -2, z: 6 }
                },
                a: { 
                    position: { x: 5, y: -2, z: 9 },
                    scale: 0.3,
                    visible: false,
                    initialPos: { x: 5, y: -2, z: 9 },
                    rotation: { x: 0, y: 0, z: -Math.PI / 6 },
                    alwaysDraggable: true
                },
                b: { 
                    position: { x: 0, y: 0, z: 10 },
                    scale: 1,
                    visible: false,
                    initialPos: { x: 0, y: 0, z: 10 },
                    color: 0xffd1dc,
                    alwaysDraggable: true
                },
                c: { 
                    position: { x: -5, y: -1, z: 9 },
                    scale: 0.01,
                    visible: false,
                    initialPos: { x: -5, y: -1, z: 9 },
                    rotation: { x: 0, y: 0, z: Math.PI / 6 },
                    alwaysDraggable: true
                },
                // ä¼˜åŒ–yanhuaæ¨¡å‹é…ç½®ï¼šå¢åŠ åŠ¨ç”»å‚æ•°
                yanhua: {
                    position: { x: 0, y: -5, z: 2 },
                    scale: 0.5,
                    visible: false,
                    initialPos: { x: 0, y: 0, z: 1.5 },
                    draggable: false,
                    // åŠ¨ç”»ç›¸å…³å‚æ•°
                    animation: {
                        loop: true,      // æ˜¯å¦å¾ªç¯æ’­æ”¾
                        speed: 2.0,      // æ’­æ”¾é€Ÿåº¦
                        autoPlay: false  // ä¸è‡ªåŠ¨æ’­æ”¾ï¼Œç­‰å¾…è§¦å‘
                    }
                }
            };
            
            const SPHERE_COORDINATES = [
                { 
                    position: { x: -6, y: -6, z: 5 },
                    color: 0xffffe0, 
                    size: 1.5, 
                    type: 'showCake', 
                    tooltip: 'åŸå‘³å¥¶æ²¹è›‹ç³•' 
                },
                { 
                    position: { x: 0, y: -6, z: 5 },
                    color: 0xffc0cb, 
                    size: 1.5, 
                    type: 'showFenSe', 
                    tooltip: 'è‰è“å¥¶æ²¹è›‹ç³•' 
                },
                { 
                    position: { x: 5, y: -6, z: 5 },
                    color: 0x9370db, 
                    size: 1.5, 
                    type: 'showZiSe', 
                    tooltip: 'è“è“å¥¶æ²¹è›‹ç³•' 
                }
            ];

            // å¸¸é‡å®šä¹‰åŒº
            const DRAGGABLE_MODELS = ['caomei', 'lanmei', 'oreo', 'yingtao', 'a', 'b', 'c'];
            const NEW_MODELS = ['a', 'b', 'c'];
            const POSITION_TOLERANCE = 0.1;

            // å±€éƒ¨å˜é‡åŒº
            const models = {};
            const spheres = [];
            let loaded = 0, total = Object.keys(MODEL_COORDINATES).length;
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let tooltip;
            let jianhaoClicked = false;
            let jianhaoConfirmed = false;
            let jianhaoFinalized = false;
            let jianhaoPermanentlyHidden = false;
            const clickableObjects = [];
            let draggedObject = null;
            const dragOffset = new THREE.Vector3();
            let isDraggingModel = false;
            let isRotatingView = false;
            let excellentText;
            let isCameraAnimating = false;
            const restartOverlay = document.getElementById('restart-overlay');

            // åˆå§‹åŒ–å‡½æ•°
            function init() {
                tooltip = document.querySelector('.tooltip');
                excellentText = document.getElementById('excellent-text');
                
                // åˆå§‹åŒ–åœºæ™¯
                scene = new THREE.Scene();
                scene.background = null;
                
                // åˆå§‹åŒ–ç›¸æœº
                camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 15, 30);

                // åˆå§‹åŒ–æ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('container').appendChild(renderer.domElement);

                // å…‰æºè®¾ç½®
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 20, 15);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 50;
                scene.add(dirLight);

                // åˆ›å»ºäº¤äº’çƒä½“
                createSpheres();

                // åˆå§‹åŒ–æ§åˆ¶å™¨
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.target.set(0, 1, 0);
                controls.maxDistance = 60;
                controls.minDistance = 10;
                controls.enableRotate = true;
                controls.enableZoom = true;
                controls.enablePan = false;

                // åˆå§‹åŒ–åŠ è½½å™¨
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                const loader = new THREE.GLTFLoader();
                loader.setDRACOLoader(dracoLoader);
                
                // åŠ è½½æ‰€æœ‰æ¨¡å‹
                loadAllModels(loader);

                // äº‹ä»¶ç›‘å¬
                window.addEventListener('resize', onResize);
                window.addEventListener('mousedown', onMouseDown, false);
                window.addEventListener('mousemove', onMouseMove, false);
                window.addEventListener('mouseup', onMouseUp, false);
                window.addEventListener('mouseleave', onMouseUp, false);
                
                // å¯åŠ¨åŠ¨ç”»
                animate();
            }

            // ç›¸æœºåŠ¨ç”»å‡½æ•°
            function animateCamera(targetPosition, duration, onComplete) {
                const startPosition = new THREE.Vector3().copy(camera.position);
                const startTime = performance.now();
                isCameraAnimating = true;
                controls.enabled = false;
                
                function update(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = progress * (2 - progress);
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        isCameraAnimating = false;
                        controls.enabled = true;
                        if (onComplete) onComplete();
                    }
                }
                
                requestAnimationFrame(update);
            }

            // æ˜¾ç¤ºexcellentæ–‡å­—å’ŒçƒŸèŠ±åŠ¨ç”»
            function showExcellent() {
                if (models.jianhao && models.jianhao.obj) {
                    models.jianhao.obj.visible = false;
                    jianhaoPermanentlyHidden = true;
                }
                
                if (models.o && models.o.obj) {
                    models.o.obj.visible = false;
                }

                // å…³é”®ä¿®æ”¹ï¼šæ˜¾ç¤ºå¹¶æ’­æ”¾yanhuaæ¨¡å‹åŠ¨ç”»
                if (models.yanhua && models.yanhua.obj) {
                    models.yanhua.obj.visible = true;
                    models.yanhua.visible = true;
                    
                    // æ’­æ”¾çƒŸèŠ±åŠ¨ç”»
                    if (animationMixers.yanhua) {
                        // é‡ç½®å¹¶æ’­æ”¾åŠ¨ç”»
                        animationMixers.yanhua.stopAllAction();
                        const animations = models.yanhua.obj.animations;
                        if (animations && animations.length > 0) {
                            const action = animationMixers.yanhua.clipAction(animations[0]);
                            action.setLoop(
                                MODEL_COORDINATES.yanhua.animation.loop ? 
                                THREE.LoopRepeat : THREE.LoopOnce
                            );
                            action.setEffectiveTimeScale(MODEL_COORDINATES.yanhua.animation.speed);
                            action.play();
                        }
                    }
                }
                
                const targetCameraPosition = new THREE.Vector3(0, 15, 15);
                animateCamera(targetCameraPosition, 1500, () => {
                    excellentText.style.opacity = 0;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.7)';
                    
                    void excellentText.offsetWidth;
                    
                    excellentText.style.opacity = 1;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(1)';
                    
                    // excellentæ¶ˆå¤±å2ç§’æ˜¾ç¤ºé‡å¯è¦†ç›–å±‚
                    setTimeout(() => {
                        excellentText.style.opacity = 0;
                        excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.7)';
                        
                        // 2ç§’åæ˜¾ç¤ºé‡å¯è¦†ç›–å±‚
                        setTimeout(() => {
                            restartOverlay.classList.remove('hidden');
                            restartOverlay.classList.add('visible');
                        }, 2000);
                    }, 2000);
                });
            }

            // çƒä½“åˆ›å»ºå‡½æ•°
            function createSpheres() {
                SPHERE_COORDINATES.forEach((sphereProps) => {
                    const geometry = new THREE.SphereGeometry(sphereProps.size, 32, 32);
                    const material = new THREE.MeshStandardMaterial({
                        color: sphereProps.color,
                        roughness: 0.8,
                        metalness: 0.1
                    });
                    
                    const sphereMesh = new THREE.Mesh(geometry, material);
                    sphereMesh.position.set(
                        sphereProps.position.x, 
                        sphereProps.position.y, 
                        sphereProps.position.z
                    );
                    
                    sphereMesh.castShadow = true;
                    sphereMesh.receiveShadow = true;
                    sphereMesh.userData.type = sphereProps.type;
                    sphereMesh.userData.isSphere = true;
                    sphereMesh.userData.tooltip = sphereProps.tooltip;
                    
                    scene.add(sphereMesh);
                    spheres.push({ mesh: sphereMesh, ...sphereProps });
                    clickableObjects.push(sphereMesh);
                });
            }

            // æ¨¡å‹åŠ è½½å‡½æ•°
            function loadAllModels(loader) {
                Object.keys(MODEL_COORDINATES).forEach(key => {
                    const coords = MODEL_COORDINATES[key];
                    models[key] = { 
                        obj: null, 
                        loaded: false, 
                        visible: coords.visible,
                        initialPos: coords.initialPos || null,
                        isConfirmed: false,
                        isNewModel: NEW_MODELS.includes(key),
                        draggable: coords.draggable || false,
                        linkToJianhao: coords.linkToJianhao || false,
                        // å­˜å‚¨åŠ¨ç”»é…ç½®
                        animation: coords.animation || null
                    };
                    
                    loadModel(loader, key, `./${key}/scene.gltf`, 
                        coords.position.x, coords.position.y, coords.position.z, 
                        coords.scale, coords.visible, 
                        coords.rotation || null, coords.color || null
                    );
                });
            }

            function getModelName(key) {
                const nameMap = {
                    cake: 'åŸå‘³è›‹ç³•',
                    zisedangao: 'ç´«è‰²è›‹ç³•',
                    fensedangao: 'ç²‰è‰²è›‹ç³•',
                    jianhao: 'åŠ å·æ§ä»¶',
                    o: 'æ¨¡å‹O',
                    caomei: 'è‰è“',
                    lanmei: 'è“è“',
                    oreo: 'å¥¥åˆ©å¥¥',
                    yingtao: 'æ¨±æ¡ƒ',
                    a: 'æ¨¡å‹A',
                    b: 'æ¨¡å‹B',
                    c: 'æ¨¡å‹C',
                    yanhua: 'çƒŸèŠ±æ¨¡å‹'
                };
                return nameMap[key] || key;
            }

            function loadModel(loader, key, url, x, y, z, scale, visible, rotation, color) {
                document.getElementById('status').textContent = `åŠ è½½${getModelName(key)}æ¨¡å‹...`;
                
                loader.load(
                    url, 
                    (gltf) => {
                        const model = gltf.scene;
                        model.position.set(x, y, z);
                        model.scale.set(scale, scale, scale);
                        model.visible = visible;
                        
                        if (rotation) {
                            model.rotation.set(rotation.x, rotation.y, rotation.z);
                        }
                        
                        // ç‰¹åˆ«å¤„ç†yanhuaæ¨¡å‹çš„åŠ¨ç”»
                        if (key === 'yanhua') {
                            // åˆ›å»ºåŠ¨ç”»æ··åˆå™¨
                            animationMixers.yanhua = new THREE.AnimationMixer(model);
                            
                            // å­˜å‚¨åŠ¨ç”»æ•°æ®
                            model.animations = gltf.animations;
                            
                            // å¦‚æœè®¾ç½®äº†è‡ªåŠ¨æ’­æ”¾ä½†æˆ‘ä»¬å¸Œæœ›æ‰‹åŠ¨è§¦å‘ï¼Œå¯ä»¥å…ˆä¸æ’­æ”¾
                            if (MODEL_COORDINATES.yanhua.animation.autoPlay) {
                                if (gltf.animations && gltf.animations.length > 0) {
                                    const action = animationMixers.yanhua.clipAction(gltf.animations[0]);
                                    action.setLoop(
                                        MODEL_COORDINATES.yanhua.animation.loop ? 
                                        THREE.LoopRepeat : THREE.LoopOnce
                                    );
                                    action.setEffectiveTimeScale(MODEL_COORDINATES.yanhua.animation.speed);
                                    // å…ˆæš‚åœï¼Œç­‰å¾…è§¦å‘
                                    action.pause();
                                }
                            }
                        }
                        
                        const coords = MODEL_COORDINATES[key];
                        model.userData = {
                            type: key,
                            draggable: coords.draggable || false,
                            isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                            isNewModel: NEW_MODELS.includes(key),
                            isJianhao: key === 'jianhao',
                            isResetButton: key === 'o',
                            initialPos: coords.initialPos || null,
                            linkToJianhao: coords.linkToJianhao || false
                        };
                        
                        // éçƒŸèŠ±æ¨¡å‹æ·»åŠ åˆ°å¯ç‚¹å‡»åˆ—è¡¨
                        if (key !== 'yanhua' && (coords.draggable || DRAGGABLE_MODELS.includes(key))) {
                            clickableObjects.push(model);
                            
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        draggable: coords.draggable || false,
                                        parentModel: model,
                                        type: key,
                                        isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                        isNewModel: NEW_MODELS.includes(key),
                                        isResetButton: key === 'o'
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        } else if (key === 'o') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        parentModel: model,
                                        type: key,
                                        isResetButton: true
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        // æ¨¡å‹æè´¨å¤„ç†
                        model.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                if (key === 'o') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0xffff00,
                                        roughness: 0.5,
                                        metalness: 0.3,
                                        emissive: color || 0xffff00,
                                        emissiveIntensity: 0.2
                                    });
                                }
                                else if (key === 'jianhao') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0x87CEEB,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                    child.userData.type = 'jianhao';
                                    child.userData.isJianhao = true;
                                    clickableObjects.push(child);
                                } 
                                else if (key === 'oreo') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0x8B4513,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                }
                                else if (key === 'caomei') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xff3838,
                                        roughness: 0.3,
                                        metalness: 0.2,
                                        emissive: 0x330000,
                                        emissiveIntensity: 0.3
                                    });
                                }
                                else if (key === 'lanmei') {
                                    child.material = new THREE.MeshLambertMaterial({
                                        color: 0x0a2463,
                                        emissive: 0x000033,
                                        emissiveIntensity: 0.3
                                    });
                                }
                                else if (key === 'b') {
                                    const lightPink = 0xffd1dc;
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: lightPink,
                                        roughness: 0.1,
                                        metalness: 0.5,
                                        emissive: lightPink,
                                        emissiveIntensity: 0.6
                                    });
                                }
                                // çƒŸèŠ±æ¨¡å‹æè´¨ä¼˜åŒ–
                                else if (key === 'yanhua') {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: color || 0xffffff,
                                        roughness: 0.1,
                                        metalness: 0.8,
                                        emissive: color || 0xffff00,
                                        emissiveIntensity: 0.8,
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                }
                                else if (!child.material || !child.material.map) {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xaaaaaa,
                                        roughness: 0.7,
                                        metalness: 0.2
                                    });
                                }
                            }
                        });
                        
                        scene.add(model);
                        models[key].obj = model;
                        models[key].loaded = true;

                        loaded++;
                        updateProgress(loaded / total);
                        if (loaded === total) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    },
                    (xhr) => {
                        const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
                        document.getElementById('status').textContent = `${getModelName(key)}æ¨¡å‹: ${pct}%`;
                        updateProgress(xhr.loaded / xhr.total);
                    },
                    (err) => {
                        console.error(`${getModelName(key)}æ¨¡å‹åŠ è½½å¤±è´¥:`, err);
                        let geom, geomSize = 1;
                        let geomColor = 0xaaaaaa;
                        
                        // æ¨¡å‹åŠ è½½å¤±è´¥æ—¶çš„é™çº§å¤„ç†
                        if (key === 'o') {
                            geom = new THREE.SphereGeometry(geomSize, 32, 32);
                            geomColor = 0xffff00;
                        }
                        else if (key === 'zisedangao') {
                            geom = new THREE.BoxGeometry(3, 3, 3);
                            geomColor = 0x9370db;
                        } else if (key === 'fensedangao') {
                            geom = new THREE.BoxGeometry(5, 5, 5);
                            geomColor = 0xffc0cb;
                        } else if (key === 'cake') {
                            geom = new THREE.BoxGeometry(5, 5, 5);
                            geomColor = 0xcccccc;
                        } else if (key === 'jianhao') {
                            geom = new THREE.BoxGeometry(2, 2, 2);
                            geomColor = 0x87CEEB;
                        } else if (key === 'caomei') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff3838;
                        }
                        else if (key === 'lanmei') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0x2a45ff;
                            const mat = new THREE.MeshLambertMaterial({
                                color: geomColor,
                                emissive: 0x000033,
                                emissiveIntensity: 0.3,
                                wireframe: true,
                                transparent: true,
                                opacity: 0.8
                            });
                            const model = new THREE.Mesh(geom, mat);
                            
                            model.userData = {
                                type: key,
                                draggable: MODEL_COORDINATES[key].draggable || false,
                                isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                isNewModel: NEW_MODELS.includes(key),
                                isJianhao: key === 'jianhao',
                                isResetButton: key === 'o',
                                initialPos: MODEL_COORDINATES[key].initialPos || null,
                                linkToJianhao: MODEL_COORDINATES[key].linkToJianhao || false
                            };
                            
                            if (rotation) {
                                model.rotation.set(rotation.x, rotation.y, rotation.z);
                            }
                            
                            if (MODEL_COORDINATES[key].draggable || DRAGGABLE_MODELS.includes(key)) {
                                clickableObjects.push(model);
                                model.traverse(child => {
                                    if (child.isMesh) {
                                        child.userData = {
                                            draggable: MODEL_COORDINATES[key].draggable || false,
                                            parentModel: model,
                                            type: key,
                                            isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                            isNewModel: NEW_MODELS.includes(key)
                                        };
                                        clickableObjects.push(child);
                                    }
                                });
                            }
                            
                            model.position.set(x, y, z);
                            model.scale.set(scale, scale, scale);
                            model.visible = visible;
                            scene.add(model);
                            
                            models[key].obj = model;
                            models[key].loaded = true;
                            loaded++;
                            updateProgress(loaded / total);
                            
                            if (loaded === total) {
                                document.getElementById('loading').style.display = 'none';
                            }
                            return;
                        }
                        else if (key === 'oreo') {
                            geom = new THREE.BoxGeometry(1 * 0.3, 1 * 0.3, 1 * 0.3);
                            geomColor = 0x8B4513;
                        } else if (key === 'yingtao') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff6347;
                        } else if (key === 'a') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff9900;
                        } else if (key === 'b') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xffd1dc;
                        } else if (key === 'c') {
                            geom = new THREE.BoxGeometry(1, 1, 1);
                            geomColor = 0xff33cc;
                        }
                        // çƒŸèŠ±æ¨¡å‹åŠ è½½å¤±è´¥æ—¶çš„é™çº§å¤„ç†
                        else if (key === 'yanhua') {
                            // åˆ›å»ºä¸€ä¸ªç®€å•çš„ç²’å­ç³»ç»Ÿæ¨¡æ‹ŸçƒŸèŠ±
                            const particlesGeometry = new THREE.BufferGeometry();
                            const particlesCount = 150;
                            const posArray = new Float32Array(particlesCount * 3);
                            
                            for(let i = 0; i < particlesCount * 3; i++) {
                                posArray[i] = (Math.random() - 0.5) * 10;
                            }
                            
                            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                            
                            const particlesMaterial = new THREE.PointsMaterial({
                                size: 0.1,
                                color: 0xffff00,
                                transparent: true,
                                opacity: 0.8,
                                blending: THREE.AdditiveBlending
                            });
                            
                            const model = new THREE.Points(particlesGeometry, particlesMaterial);
                            
                            // å­˜å‚¨åŠ¨ç”»é…ç½®
                            model.userData = {
                                type: key,
                                draggable: false,
                                initialPos: MODEL_COORDINATES[key].initialPos || null,
                                isFallback: true // æ ‡è®°ä¸ºé™çº§æ¨¡å‹
                            };
                            
                            if (rotation) {
                                model.rotation.set(rotation.x, rotation.y, rotation.z);
                            }
                            
                            model.position.set(x, y, z);
                            model.scale.set(scale, scale, scale);
                            model.visible = visible;
                            scene.add(model);
                            
                            // ä¸ºé™çº§æ¨¡å‹åˆ›å»ºç®€å•çš„åŠ¨ç”»
                            animationMixers.yanhua = {
                                update: function(delta) {
                                    model.rotation.y += delta * 0.5;
                                    const points = model.geometry.attributes.position.array;
                                    for(let i = 0; i < points.length; i += 3) {
                                        points[i] += (Math.random() - 0.5) * 0.05;
                                        points[i + 1] += (Math.random() - 0.5) * 0.05;
                                        points[i + 2] += (Math.random() - 0.5) * 0.05;
                                    }
                                    model.geometry.attributes.position.needsUpdate = true;
                                },
                                stopAllAction: function() {},
                                clipAction: function() {
                                    return { play: function() {}, pause: function() {} };
                                }
                            };
                            
                            models[key].obj = model;
                            models[key].loaded = true;
                            loaded++;
                            updateProgress(loaded / total);
                            
                            if (loaded === total) {
                                document.getElementById('loading').style.display = 'none';
                            }
                            return;
                        }
                        else {
                            geom = new THREE.BoxGeometry(geomSize, geomSize, geomSize);
                        }
                        
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: geomColor, 
                            wireframe: true,
                            transparent: true,
                            opacity: 0.8
                        });
                        const model = new THREE.Mesh(geom, mat);
                        
                        model.userData = {
                            type: key,
                            draggable: MODEL_COORDINATES[key].draggable || false,
                            isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                            isNewModel: NEW_MODELS.includes(key),
                            isJianhao: key === 'jianhao',
                            isResetButton: key === 'o',
                            initialPos: MODEL_COORDINATES[key].initialPos || null,
                            linkToJianhao: MODEL_COORDINATES[key].linkToJianhao || false
                        };
                        
                        if (rotation) {
                            model.rotation.set(rotation.x, rotation.y, rotation.z);
                        }
                        
                        if (MODEL_COORDINATES[key].draggable || DRAGGABLE_MODELS.includes(key)) {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        draggable: MODEL_COORDINATES[key].draggable || false,
                                        parentModel: model,
                                        type: key,
                                        isFruit: DRAGGABLE_MODELS.includes(key) && !NEW_MODELS.includes(key),
                                        isNewModel: NEW_MODELS.includes(key)
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        } else if (key === 'o') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData = {
                                        parentModel: model,
                                        type: key,
                                        isResetButton: true
                                    };
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        if (key === 'jianhao') {
                            clickableObjects.push(model);
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.userData.isJianhao = true;
                                    clickableObjects.push(child);
                                }
                            });
                        }
                        
                        model.position.set(x, y, z);
                        model.scale.set(scale, scale, scale);
                        model.visible = visible;
                        scene.add(model);
                        
                        models[key].obj = model;
                        models[key].loaded = true;
                        loaded++;
                        updateProgress(loaded / total);
                        
                        if (loaded === total) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    }
                );
            }

            // è¾…åŠ©å‡½æ•°
            function isAtInitialPosition(modelKey) {
                const model = models[modelKey];
                if (!model || !model.obj || !model.initialPos) return false;
                
                const currentPos = model.obj.position;
                const initialPos = model.initialPos;
                
                const xMatch = Math.abs(currentPos.x - initialPos.x) <= POSITION_TOLERANCE;
                const yMatch = Math.abs(currentPos.y - initialPos.y) <= POSITION_TOLERANCE;
                const zMatch = Math.abs(currentPos.z - initialPos.z) <= POSITION_TOLERANCE;
                
                return xMatch && yMatch && zMatch;
            }

            function updateFruitsAfterConfirmation() {
                DRAGGABLE_MODELS.filter(key => !NEW_MODELS.includes(key)).forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    const atInitialPos = isAtInitialPosition(modelKey);
                    model.obj.visible = !atInitialPos;
                    model.visible = !atInitialPos;
                    model.obj.userData.draggable = false;
                    model.isConfirmed = true;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = false;
                        }
                    });
                });
                
                NEW_MODELS.forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    model.obj.visible = true;
                    model.visible = true;
                    model.obj.userData.draggable = true;
                    model.isConfirmed = false;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = true;
                        }
                    });
                });
                
                tooltip.style.opacity = 1;
                tooltip.textContent = 'æ¨¡å‹Aã€Bã€Cå·²æ˜¾ç¤ºï¼Œå¯ç‚¹å‡»æ‹–åŠ¨å®ƒä»¬';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 3000);
            }

            function finalizeNewModels() {
                NEW_MODELS.forEach(modelKey => {
                    const model = models[modelKey];
                    if (!model || !model.obj) return;
                    
                    const atInitialPos = isAtInitialPosition(modelKey);
                    
                    model.obj.visible = !atInitialPos;
                    model.visible = !atInitialPos;
                    model.obj.userData.draggable = false;
                    model.isConfirmed = true;
                    
                    model.obj.traverse(child => {
                        if (child.isMesh) {
                            child.userData.draggable = false;
                        }
                    });
                });
                
                tooltip.style.opacity = 1;
                tooltip.textContent = 'å·²ç¡®è®¤æœ€ç»ˆçŠ¶æ€ï¼šç§»åŠ¨è¿‡çš„æ¨¡å‹ä¿ç•™ï¼Œæœªç§»åŠ¨çš„æ¨¡å‹å·²éšè—';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 3000);
                
                showExcellent();
            }

            // é‡ç½®å½“å‰3Dåœºæ™¯çŠ¶æ€
            function resetCurrentSession() {
                jianhaoClicked = false;
                jianhaoConfirmed = false;
                jianhaoFinalized = false;
                jianhaoPermanentlyHidden = false;
                draggedObject = null;
                isDraggingModel = false;
                isRotatingView = false;
                isCameraAnimating = false;
                
                if (excellentText) {
                    excellentText.style.opacity = 0;
                    excellentText.style.transform = 'translate(-50%, -50%) rotate(-2deg) scale(0.9)';
                }

                // é‡ç½®yanhuaæ¨¡å‹çŠ¶æ€
                if (models.yanhua && models.yanhua.obj) {
                    models.yanhua.obj.visible = false;
                    models.yanhua.visible = false;
                    
                    // åœæ­¢çƒŸèŠ±åŠ¨ç”»
                    if (animationMixers.yanhua) {
                        animationMixers.yanhua.stopAllAction();
                    }
                }
                
                Object.keys(MODEL_COORDINATES).forEach(key => {
                    const coords = MODEL_COORDINATES[key];
                    const model = models[key];
                    
                    if (model && model.obj) {
                        model.obj.position.set(
                            coords.position.x,
                            coords.position.y,
                            coords.position.z
                        );
                        
                        if (coords.rotation) {
                            model.obj.rotation.set(
                                coords.rotation.x,
                                coords.rotation.y,
                                coords.rotation.z
                            );
                        } else {
                            model.obj.rotation.set(0, 0, 0);
                        }
                        
                        model.obj.visible = coords.visible;
                        model.visible = coords.visible;
                        
                        const isDraggable = coords.draggable || DRAGGABLE_MODELS.includes(key);
                        model.obj.userData.draggable = isDraggable;
                        model.isConfirmed = false;
                        
                        model.obj.traverse(child => {
                            if (child.isMesh) {
                                child.userData.draggable = isDraggable;
                            }
                        });
                    }
                });
                
                spheres.forEach(sphere => {
                    if (sphere.mesh) {
                        sphere.mesh.visible = true;
                    }
                });
                
                if (camera && controls) {
                    camera.position.set(0, 15, 30);
                    controls.target.set(0, 1, 0);
                    controls.reset();
                    controls.enabled = true;
                }
                
                tooltip.style.opacity = 1;
                tooltip.textContent = 'å·²é‡ç½®å½“å‰ä¼šè¯';
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                }, 2000);
            }

            // äº‹ä»¶å¤„ç†å‡½æ•°
            function onMouseDown(event) {
                if (isCameraAnimating) return;
                
                if (jianhaoPermanentlyHidden) {
                    const tempClickableObjects = clickableObjects.filter(obj => 
                        !(obj.userData.isJianhao || obj.userData.type === 'o' || 
                          (obj.parent && (obj.parent.userData.isJianhao || obj.parent.userData.type === 'o')))
                    );
                }
                
                event.preventDefault();
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(clickableObjects, true);
                
                isDraggingModel = false;
                isRotatingView = false;
                draggedObject = null;
                
                let clickedResetButton = false;
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    clickedResetButton = obj.userData.isResetButton || 
                                      (obj.parent && obj.parent.userData.isResetButton);
                    
                    if (clickedResetButton) {
                        resetCurrentSession();
                        return;
                    }
                }
                
                let clickedJianhao = false;
                if (!jianhaoPermanentlyHidden && intersects.length > 0) {
                    const obj = intersects[0].object;
                    clickedJianhao = obj.userData.isJianhao || 
                                    (obj.parent && obj.parent.userData.isJianhao);
                }
                
                if (clickedJianhao) {
                    if (!jianhaoClicked) {
                        jianhaoClicked = true;
                        jianhaoConfirmed = false;
                        jianhaoFinalized = false;
                        spheres.forEach(sphere => sphere.mesh && (sphere.mesh.visible = false));
                        
                        DRAGGABLE_MODELS.forEach(modelKey => {
                            const isNew = NEW_MODELS.includes(modelKey);
                            setModelVisibility(modelKey, !isNew);
                            
                            if (models[modelKey] && models[modelKey].obj) {
                                models[modelKey].obj.userData.draggable = !isNew;
                                models[modelKey].obj.traverse(child => {
                                    if (child.isMesh) child.userData.draggable = !isNew;
                                });
                                models[modelKey].isConfirmed = false;
                            }
                        });
                        
                        tooltip.style.opacity = 1;
                        tooltip.textContent = 'æ‹–åŠ¨æ°´æœè°ƒæ•´ä½ç½®ï¼Œå†æ¬¡ç‚¹å‡»åŠ å·ç¡®è®¤';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                        return;
                    } else if (!jianhaoConfirmed) {
                        jianhaoConfirmed = true;
                        jianhaoFinalized = false;
                        updateFruitsAfterConfirmation();
                        return;
                    } else if (!jianhaoFinalized) {
                        jianhaoFinalized = true;
                        finalizeNewModels();
                        return;
                    } else {
                        jianhaoFinalized = false;
                        jianhaoConfirmed = false;
                        
                        if (models.jianhao && models.jianhao.obj) {
                            models.jianhao.obj.visible = true;
                        }
                        if (models.o && models.o.obj) {
                            models.o.obj.visible = true;
                        }
                        
                        DRAGGABLE_MODELS.forEach(modelKey => {
                            setModelVisibility(modelKey, true);
                            if (models[modelKey] && models[modelKey].obj) {
                                models[modelKey].obj.userData.draggable = true;
                                models[modelKey].obj.traverse(child => {
                                    if (child.isMesh) child.userData.draggable = true;
                                });
                                models[modelKey].isConfirmed = false;
                            }
                        });
                        
                        tooltip.style.opacity = 1;
                        tooltip.textContent = 'å¯é‡æ–°è°ƒæ•´æ‰€æœ‰æ¨¡å‹ä½ç½®ï¼Œå†æ¬¡ç‚¹å‡»åŠ å·ç¡®è®¤';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                        return;
                    }
                }
                
                if (!jianhaoClicked && intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    if (clickedObject.userData.isSphere) {
                        switch (clickedObject.userData.type) {
                            case 'showCake':
                                setModelVisibility('cake', true);
                                setModelVisibility('zisedangao', false);
                                setModelVisibility('fensedangao', false);
                                break;
                            case 'showFenSe':
                                setModelVisibility('cake', false);
                                setModelVisibility('zisedangao', false);
                                setModelVisibility('fensedangao', true);
                                break;
                            case 'showZiSe':
                                setModelVisibility('cake', false);
                                setModelVisibility('zisedangao', true);
                                setModelVisibility('fensedangao', false);
                                break;
                        }
                        return;
                    }
                }
                
                if (!jianhaoFinalized && intersects.length > 0) {
                    for (let i = 0; i < intersects.length; i++) {
                        const intersect = intersects[i];
                        let targetObject = intersect.object;
                        
                        if (targetObject.userData.type === 'o' || 
                            (targetObject.parent && targetObject.parent.userData.type === 'o')) {
                            continue;
                        }
                        
                        if (targetObject.userData.draggable || 
                           (targetObject.parent && targetObject.parent.userData.draggable)) {
                            
                            draggedObject = targetObject.userData.parentModel || targetObject;
                        }
                        
                        if (draggedObject) {
                            isDraggingModel = true;
                            controls.enabled = false;
                            
                            const plane = new THREE.Plane();
                            plane.setFromNormalAndCoplanarPoint(
                                camera.getWorldDirection(new THREE.Vector3()),
                                draggedObject.getWorldPosition(new THREE.Vector3())
                            );
                            
                            const intersectionPoint = new THREE.Vector3();
                            raycaster.ray.intersectPlane(plane, intersectionPoint);
                            
                            dragOffset.copy(draggedObject.getWorldPosition(new THREE.Vector3()))
                                  .sub(intersectionPoint);
                            
                            document.body.style.cursor = 'grabbing';
                            break;
                        }
                    }
                }
                
                if (!draggedObject && !clickedJianhao) {
                    isRotatingView = true;
                    controls.enabled = true;
                    document.body.style.cursor = 'grabbing';
                }
            }

            function onMouseMove(event) {
                if (isCameraAnimating) return;
                
                event.preventDefault();
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (!jianhaoFinalized && draggedObject && isDraggingModel) {
                    if (draggedObject.userData.type === 'o' || 
                        (draggedObject.parent && draggedObject.parent.userData.type === 'o')) {
                        return;
                    }
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const plane = new THREE.Plane();
                    plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection(new THREE.Vector3()),
                        draggedObject.getWorldPosition(new THREE.Vector3())
                    );
                    
                    const intersectionPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectionPoint);
                    
                    const newPosition = new THREE.Vector3()
                        .copy(intersectionPoint)
                        .add(dragOffset);
                    
                    if (draggedObject.userData.alwaysDraggable) {
                        draggedObject.position.copy(newPosition);
                    } else {
                        newPosition.y = Math.max(newPosition.y, -1.8);
                        draggedObject.position.copy(newPosition);
                    }
                    return;
                }
                
                if (!jianhaoClicked) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(clickableObjects, false);
                    
                    let hoveredSphere = null;
                    let tooltipText = '';
                    
                    for (let i = 0; i < intersects.length; i++) {
                        if (intersects[i].object.userData.isSphere) {
                            for (let j = 0; j < spheres.length; j++) {
                                if (spheres[j].mesh === intersects[i].object) {
                                    hoveredSphere = spheres[j];
                                    tooltipText = spheres[j].tooltip;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    
                    if (hoveredSphere) {
                        tooltip.style.opacity = 1;
                        tooltip.textContent = tooltipText;
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                    } else {
                        tooltip.style.opacity = 0;
                    }
                } else if (!jianhaoFinalized) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(clickableObjects, true);
                    let isHoveringDraggable = false;
                    
                    for (let i = 0; i < intersects.length; i++) {
                        const obj = intersects[i].object;
                        if (obj.userData.type === 'o' || (obj.parent && obj.parent.userData.type === 'o')) {
                            continue;
                        }
                        
                        if (obj.userData.draggable || 
                           (obj.parent && obj.parent.userData.draggable)) {
                            isHoveringDraggable = true;
                            break;
                        }
                    }
                    
                    if (isHoveringDraggable) {
                        tooltip.style.opacity = 1;
                        tooltip.textContent = 'ç‚¹å‡»å¹¶æ‹–åŠ¨è°ƒæ•´ä½ç½®';
                        tooltip.style.left = (event.clientX + 10) + 'px';
                        tooltip.style.top = (event.clientY - 20) + 'px';
                    } else if (!draggedObject) {
                        tooltip.style.opacity = 0;
                    }
                } else {
                    tooltip.style.opacity = 0;
                }
            }

            function onMouseUp() {
                if (isCameraAnimating) return;
                
                if (draggedObject) {
                    draggedObject = null;
                    isDraggingModel = false;
                }
                
                isRotatingView = false;
                controls.enabled = true;
                document.body.style.cursor = 'default';
            }

            // å·¥å…·å‡½æ•°
            function setModelVisibility(modelKey, visible) {
                if (modelKey === 'jianhao' && jianhaoPermanentlyHidden) {
                    if (models.o && models.o.obj) {
                        models.o.obj.visible = false;
                    }
                    return;
                }
                
                if (modelKey === 'o' && models.o.linkToJianhao) {
                    visible = models.jianhao ? models.jianhao.visible : false;
                }
                
                if (models[modelKey] && models[modelKey].obj) {
                    models[modelKey].obj.visible = visible;
                    models[modelKey].visible = visible;
                    
                    if (modelKey === 'jianhao' && models.o && models.o.obj && models.o.linkToJianhao) {
                        models.o.obj.visible = visible;
                        models.o.visible = visible;
                    }
                }
            }

            function updateProgress(ratio) {
                const pct = Math.round(ratio * 100);
                document.getElementById('progress-bar').style.width = pct + '%';
            }

            function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                // æ›´æ–°æ‰€æœ‰åŠ¨ç”»æ··åˆå™¨
                const delta = clock.getDelta();
                for (const key in animationMixers) {
                    if (animationMixers.hasOwnProperty(key) && typeof animationMixers[key].update === 'function') {
                        animationMixers[key].update(delta);
                    }
                }
                controls.update();
                renderer.render(scene, camera);
            }

            // å¯åŠ¨3Dåˆå§‹åŒ–
            init();
            
        }
       // èƒŒæ™¯éšé¼ æ ‡è½»å¾®åç§» + ç¼©æ”¾
document.addEventListener("mousemove", (e) => {
    const moveX = (e.clientX / window.innerWidth - 0.5) * 10;
    const moveY = (e.clientY / window.innerHeight - 0.5) * 10;
    const scale = 1.02 + Math.abs(moveX) / 200 + Math.abs(moveY) / 200; 

    const overlay = document.getElementById("overlay");
    if (overlay) {
        overlay.style.backgroundPosition = `${50 + moveX}% ${50 + moveY}%`;
        overlay.style.transform = `scale(${scale})`;
    }
});

// è‡ªå®šä¹‰é¼ æ ‡
const cursor = document.getElementById('custom-cursor');
if (cursor) {
    cursor.style.position = "fixed";
    cursor.style.width = "40px";
    cursor.style.height = "40px";
    cursor.style.pointerEvents = "none";
    cursor.style.transform = "translate(-50%, -50%)";
    cursor.style.zIndex = "10000";
}

document.addEventListener('mousemove', e => {
    if (cursor) {
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
    }
});

// é¡µé¢å¤§å°æ”¹å˜
window.addEventListener('resize', () => {
    if (typeof camera !== 'undefined' && typeof renderer !== 'undefined') {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
});
</script>
</body>
</html>
